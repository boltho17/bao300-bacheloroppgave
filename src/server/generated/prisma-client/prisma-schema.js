module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCategory {
  count: Int!
}

type AggregateContentArea {
  count: Int!
}

type AggregateContentText {
  count: Int!
}

type AggregateCountry {
  count: Int!
}

type AggregateCustomer {
  count: Int!
}

type AggregateGrind {
  count: Int!
}

type AggregateGrindOption {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregateOrderLine {
  count: Int!
}

type AggregateOrigin {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateProductImage {
  count: Int!
}

type AggregateRegion {
  count: Int!
}

type AggregateReview {
  count: Int!
}

type AggregateSKU {
  count: Int!
}

type AggregateSubCategory {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateVendor {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Category {
  id: ID!
  products: Product!
  category: String!
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  id: ID
  products: ProductCreateOneWithoutCategoriesInput!
  category: String!
}

input CategoryCreateManyWithoutProductsInput {
  create: [CategoryCreateWithoutProductsInput!]
  connect: [CategoryWhereUniqueInput!]
}

input CategoryCreateOneInput {
  create: CategoryCreateInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateWithoutProductsInput {
  id: ID
  category: String!
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  category_ASC
  category_DESC
}

type CategoryPreviousValues {
  id: ID!
  category: String!
}

input CategoryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  AND: [CategoryScalarWhereInput!]
  OR: [CategoryScalarWhereInput!]
  NOT: [CategoryScalarWhereInput!]
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateDataInput {
  products: ProductUpdateOneRequiredWithoutCategoriesInput
  category: String
}

input CategoryUpdateInput {
  products: ProductUpdateOneRequiredWithoutCategoriesInput
  category: String
}

input CategoryUpdateManyDataInput {
  category: String
}

input CategoryUpdateManyMutationInput {
  category: String
}

input CategoryUpdateManyWithoutProductsInput {
  create: [CategoryCreateWithoutProductsInput!]
  delete: [CategoryWhereUniqueInput!]
  connect: [CategoryWhereUniqueInput!]
  set: [CategoryWhereUniqueInput!]
  disconnect: [CategoryWhereUniqueInput!]
  update: [CategoryUpdateWithWhereUniqueWithoutProductsInput!]
  upsert: [CategoryUpsertWithWhereUniqueWithoutProductsInput!]
  deleteMany: [CategoryScalarWhereInput!]
  updateMany: [CategoryUpdateManyWithWhereNestedInput!]
}

input CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput!
  data: CategoryUpdateManyDataInput!
}

input CategoryUpdateOneRequiredInput {
  create: CategoryCreateInput
  update: CategoryUpdateDataInput
  upsert: CategoryUpsertNestedInput
  connect: CategoryWhereUniqueInput
}

input CategoryUpdateWithoutProductsDataInput {
  category: String
}

input CategoryUpdateWithWhereUniqueWithoutProductsInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateWithoutProductsDataInput!
}

input CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput!
  create: CategoryCreateInput!
}

input CategoryUpsertWithWhereUniqueWithoutProductsInput {
  where: CategoryWhereUniqueInput!
  update: CategoryUpdateWithoutProductsDataInput!
  create: CategoryCreateWithoutProductsInput!
}

input CategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  products: ProductWhereInput
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
  category: String
}

type ContentArea {
  id: ID!
  name: String!
}

type ContentAreaConnection {
  pageInfo: PageInfo!
  edges: [ContentAreaEdge]!
  aggregate: AggregateContentArea!
}

input ContentAreaCreateInput {
  id: ID
  name: String!
}

input ContentAreaCreateOneInput {
  create: ContentAreaCreateInput
  connect: ContentAreaWhereUniqueInput
}

type ContentAreaEdge {
  node: ContentArea!
  cursor: String!
}

enum ContentAreaOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ContentAreaPreviousValues {
  id: ID!
  name: String!
}

type ContentAreaSubscriptionPayload {
  mutation: MutationType!
  node: ContentArea
  updatedFields: [String!]
  previousValues: ContentAreaPreviousValues
}

input ContentAreaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContentAreaWhereInput
  AND: [ContentAreaSubscriptionWhereInput!]
  OR: [ContentAreaSubscriptionWhereInput!]
  NOT: [ContentAreaSubscriptionWhereInput!]
}

input ContentAreaUpdateDataInput {
  name: String
}

input ContentAreaUpdateInput {
  name: String
}

input ContentAreaUpdateManyMutationInput {
  name: String
}

input ContentAreaUpdateOneRequiredInput {
  create: ContentAreaCreateInput
  update: ContentAreaUpdateDataInput
  upsert: ContentAreaUpsertNestedInput
  connect: ContentAreaWhereUniqueInput
}

input ContentAreaUpsertNestedInput {
  update: ContentAreaUpdateDataInput!
  create: ContentAreaCreateInput!
}

input ContentAreaWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ContentAreaWhereInput!]
  OR: [ContentAreaWhereInput!]
  NOT: [ContentAreaWhereInput!]
}

input ContentAreaWhereUniqueInput {
  id: ID
}

type ContentText {
  id: ID!
  vendor: Vendor!
  contentArea: ContentArea!
  content: String!
  publishedStatus: Boolean!
}

type ContentTextConnection {
  pageInfo: PageInfo!
  edges: [ContentTextEdge]!
  aggregate: AggregateContentText!
}

input ContentTextCreateInput {
  id: ID
  vendor: VendorCreateOneInput!
  contentArea: ContentAreaCreateOneInput!
  content: String!
  publishedStatus: Boolean
}

type ContentTextEdge {
  node: ContentText!
  cursor: String!
}

enum ContentTextOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  publishedStatus_ASC
  publishedStatus_DESC
}

type ContentTextPreviousValues {
  id: ID!
  content: String!
  publishedStatus: Boolean!
}

type ContentTextSubscriptionPayload {
  mutation: MutationType!
  node: ContentText
  updatedFields: [String!]
  previousValues: ContentTextPreviousValues
}

input ContentTextSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContentTextWhereInput
  AND: [ContentTextSubscriptionWhereInput!]
  OR: [ContentTextSubscriptionWhereInput!]
  NOT: [ContentTextSubscriptionWhereInput!]
}

input ContentTextUpdateInput {
  vendor: VendorUpdateOneRequiredInput
  contentArea: ContentAreaUpdateOneRequiredInput
  content: String
  publishedStatus: Boolean
}

input ContentTextUpdateManyMutationInput {
  content: String
  publishedStatus: Boolean
}

input ContentTextWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  vendor: VendorWhereInput
  contentArea: ContentAreaWhereInput
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  publishedStatus: Boolean
  publishedStatus_not: Boolean
  AND: [ContentTextWhereInput!]
  OR: [ContentTextWhereInput!]
  NOT: [ContentTextWhereInput!]
}

input ContentTextWhereUniqueInput {
  id: ID
}

type Country {
  id: ID!
  name: String!
  region: Region
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
}

type CountryConnection {
  pageInfo: PageInfo!
  edges: [CountryEdge]!
  aggregate: AggregateCountry!
}

input CountryCreateInput {
  id: ID
  name: String!
  region: RegionCreateOneWithoutCountriesInput
  products: ProductCreateManyWithoutCountryInput
}

input CountryCreateManyWithoutRegionInput {
  create: [CountryCreateWithoutRegionInput!]
  connect: [CountryWhereUniqueInput!]
}

input CountryCreateOneWithoutProductsInput {
  create: CountryCreateWithoutProductsInput
  connect: CountryWhereUniqueInput
}

input CountryCreateWithoutProductsInput {
  id: ID
  name: String!
  region: RegionCreateOneWithoutCountriesInput
}

input CountryCreateWithoutRegionInput {
  id: ID
  name: String!
  products: ProductCreateManyWithoutCountryInput
}

type CountryEdge {
  node: Country!
  cursor: String!
}

enum CountryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type CountryPreviousValues {
  id: ID!
  name: String!
}

input CountryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [CountryScalarWhereInput!]
  OR: [CountryScalarWhereInput!]
  NOT: [CountryScalarWhereInput!]
}

type CountrySubscriptionPayload {
  mutation: MutationType!
  node: Country
  updatedFields: [String!]
  previousValues: CountryPreviousValues
}

input CountrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CountryWhereInput
  AND: [CountrySubscriptionWhereInput!]
  OR: [CountrySubscriptionWhereInput!]
  NOT: [CountrySubscriptionWhereInput!]
}

input CountryUpdateInput {
  name: String
  region: RegionUpdateOneWithoutCountriesInput
  products: ProductUpdateManyWithoutCountryInput
}

input CountryUpdateManyDataInput {
  name: String
}

input CountryUpdateManyMutationInput {
  name: String
}

input CountryUpdateManyWithoutRegionInput {
  create: [CountryCreateWithoutRegionInput!]
  delete: [CountryWhereUniqueInput!]
  connect: [CountryWhereUniqueInput!]
  set: [CountryWhereUniqueInput!]
  disconnect: [CountryWhereUniqueInput!]
  update: [CountryUpdateWithWhereUniqueWithoutRegionInput!]
  upsert: [CountryUpsertWithWhereUniqueWithoutRegionInput!]
  deleteMany: [CountryScalarWhereInput!]
  updateMany: [CountryUpdateManyWithWhereNestedInput!]
}

input CountryUpdateManyWithWhereNestedInput {
  where: CountryScalarWhereInput!
  data: CountryUpdateManyDataInput!
}

input CountryUpdateOneWithoutProductsInput {
  create: CountryCreateWithoutProductsInput
  update: CountryUpdateWithoutProductsDataInput
  upsert: CountryUpsertWithoutProductsInput
  delete: Boolean
  disconnect: Boolean
  connect: CountryWhereUniqueInput
}

input CountryUpdateWithoutProductsDataInput {
  name: String
  region: RegionUpdateOneWithoutCountriesInput
}

input CountryUpdateWithoutRegionDataInput {
  name: String
  products: ProductUpdateManyWithoutCountryInput
}

input CountryUpdateWithWhereUniqueWithoutRegionInput {
  where: CountryWhereUniqueInput!
  data: CountryUpdateWithoutRegionDataInput!
}

input CountryUpsertWithoutProductsInput {
  update: CountryUpdateWithoutProductsDataInput!
  create: CountryCreateWithoutProductsInput!
}

input CountryUpsertWithWhereUniqueWithoutRegionInput {
  where: CountryWhereUniqueInput!
  update: CountryUpdateWithoutRegionDataInput!
  create: CountryCreateWithoutRegionInput!
}

input CountryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  region: RegionWhereInput
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  AND: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  NOT: [CountryWhereInput!]
}

input CountryWhereUniqueInput {
  id: ID
  name: String
}

type Customer {
  id: ID!
  firstName: String!
  lastName: String!
  address: String
  user: User!
}

type CustomerConnection {
  pageInfo: PageInfo!
  edges: [CustomerEdge]!
  aggregate: AggregateCustomer!
}

input CustomerCreateInput {
  id: ID
  firstName: String!
  lastName: String!
  address: String
  user: UserCreateOneWithoutCustomerInput!
}

input CustomerCreateOneInput {
  create: CustomerCreateInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateOneWithoutUserInput {
  create: CustomerCreateWithoutUserInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateWithoutUserInput {
  id: ID
  firstName: String!
  lastName: String!
  address: String
}

type CustomerEdge {
  node: Customer!
  cursor: String!
}

enum CustomerOrderByInput {
  id_ASC
  id_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  address_ASC
  address_DESC
}

type CustomerPreviousValues {
  id: ID!
  firstName: String!
  lastName: String!
  address: String
}

type CustomerSubscriptionPayload {
  mutation: MutationType!
  node: Customer
  updatedFields: [String!]
  previousValues: CustomerPreviousValues
}

input CustomerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerWhereInput
  AND: [CustomerSubscriptionWhereInput!]
  OR: [CustomerSubscriptionWhereInput!]
  NOT: [CustomerSubscriptionWhereInput!]
}

input CustomerUpdateDataInput {
  firstName: String
  lastName: String
  address: String
  user: UserUpdateOneRequiredWithoutCustomerInput
}

input CustomerUpdateInput {
  firstName: String
  lastName: String
  address: String
  user: UserUpdateOneRequiredWithoutCustomerInput
}

input CustomerUpdateManyMutationInput {
  firstName: String
  lastName: String
  address: String
}

input CustomerUpdateOneRequiredInput {
  create: CustomerCreateInput
  update: CustomerUpdateDataInput
  upsert: CustomerUpsertNestedInput
  connect: CustomerWhereUniqueInput
}

input CustomerUpdateOneWithoutUserInput {
  create: CustomerCreateWithoutUserInput
  update: CustomerUpdateWithoutUserDataInput
  upsert: CustomerUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: CustomerWhereUniqueInput
}

input CustomerUpdateWithoutUserDataInput {
  firstName: String
  lastName: String
  address: String
}

input CustomerUpsertNestedInput {
  update: CustomerUpdateDataInput!
  create: CustomerCreateInput!
}

input CustomerUpsertWithoutUserInput {
  update: CustomerUpdateWithoutUserDataInput!
  create: CustomerCreateWithoutUserInput!
}

input CustomerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  user: UserWhereInput
  AND: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
}

input CustomerWhereUniqueInput {
  id: ID
}

scalar DateTime

type Grind {
  id: ID!
  Ja: Boolean
  Nei: Boolean
  Espressomaskin: Boolean
  Espressokanne: Boolean
  Aeropress: Boolean
  DryppV60: Boolean
  Filtermalt: Boolean
  Presskanne: Boolean
  Chemex: Boolean
  Kokmalt: Boolean
}

type GrindConnection {
  pageInfo: PageInfo!
  edges: [GrindEdge]!
  aggregate: AggregateGrind!
}

input GrindCreateInput {
  id: ID
  Ja: Boolean
  Nei: Boolean
  Espressomaskin: Boolean
  Espressokanne: Boolean
  Aeropress: Boolean
  DryppV60: Boolean
  Filtermalt: Boolean
  Presskanne: Boolean
  Chemex: Boolean
  Kokmalt: Boolean
}

input GrindCreateOneInput {
  create: GrindCreateInput
  connect: GrindWhereUniqueInput
}

type GrindEdge {
  node: Grind!
  cursor: String!
}

type GrindOption {
  id: ID!
  product: Product!
  grind: Grind!
}

type GrindOptionConnection {
  pageInfo: PageInfo!
  edges: [GrindOptionEdge]!
  aggregate: AggregateGrindOption!
}

input GrindOptionCreateInput {
  id: ID
  product: ProductCreateOneInput!
  grind: GrindCreateOneInput!
}

type GrindOptionEdge {
  node: GrindOption!
  cursor: String!
}

enum GrindOptionOrderByInput {
  id_ASC
  id_DESC
}

type GrindOptionPreviousValues {
  id: ID!
}

type GrindOptionSubscriptionPayload {
  mutation: MutationType!
  node: GrindOption
  updatedFields: [String!]
  previousValues: GrindOptionPreviousValues
}

input GrindOptionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GrindOptionWhereInput
  AND: [GrindOptionSubscriptionWhereInput!]
  OR: [GrindOptionSubscriptionWhereInput!]
  NOT: [GrindOptionSubscriptionWhereInput!]
}

input GrindOptionUpdateInput {
  product: ProductUpdateOneRequiredInput
  grind: GrindUpdateOneRequiredInput
}

input GrindOptionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  product: ProductWhereInput
  grind: GrindWhereInput
  AND: [GrindOptionWhereInput!]
  OR: [GrindOptionWhereInput!]
  NOT: [GrindOptionWhereInput!]
}

input GrindOptionWhereUniqueInput {
  id: ID
}

enum GrindOrderByInput {
  id_ASC
  id_DESC
  Ja_ASC
  Ja_DESC
  Nei_ASC
  Nei_DESC
  Espressomaskin_ASC
  Espressomaskin_DESC
  Espressokanne_ASC
  Espressokanne_DESC
  Aeropress_ASC
  Aeropress_DESC
  DryppV60_ASC
  DryppV60_DESC
  Filtermalt_ASC
  Filtermalt_DESC
  Presskanne_ASC
  Presskanne_DESC
  Chemex_ASC
  Chemex_DESC
  Kokmalt_ASC
  Kokmalt_DESC
}

type GrindPreviousValues {
  id: ID!
  Ja: Boolean
  Nei: Boolean
  Espressomaskin: Boolean
  Espressokanne: Boolean
  Aeropress: Boolean
  DryppV60: Boolean
  Filtermalt: Boolean
  Presskanne: Boolean
  Chemex: Boolean
  Kokmalt: Boolean
}

type GrindSubscriptionPayload {
  mutation: MutationType!
  node: Grind
  updatedFields: [String!]
  previousValues: GrindPreviousValues
}

input GrindSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GrindWhereInput
  AND: [GrindSubscriptionWhereInput!]
  OR: [GrindSubscriptionWhereInput!]
  NOT: [GrindSubscriptionWhereInput!]
}

input GrindUpdateDataInput {
  Ja: Boolean
  Nei: Boolean
  Espressomaskin: Boolean
  Espressokanne: Boolean
  Aeropress: Boolean
  DryppV60: Boolean
  Filtermalt: Boolean
  Presskanne: Boolean
  Chemex: Boolean
  Kokmalt: Boolean
}

input GrindUpdateInput {
  Ja: Boolean
  Nei: Boolean
  Espressomaskin: Boolean
  Espressokanne: Boolean
  Aeropress: Boolean
  DryppV60: Boolean
  Filtermalt: Boolean
  Presskanne: Boolean
  Chemex: Boolean
  Kokmalt: Boolean
}

input GrindUpdateManyMutationInput {
  Ja: Boolean
  Nei: Boolean
  Espressomaskin: Boolean
  Espressokanne: Boolean
  Aeropress: Boolean
  DryppV60: Boolean
  Filtermalt: Boolean
  Presskanne: Boolean
  Chemex: Boolean
  Kokmalt: Boolean
}

input GrindUpdateOneInput {
  create: GrindCreateInput
  update: GrindUpdateDataInput
  upsert: GrindUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: GrindWhereUniqueInput
}

input GrindUpdateOneRequiredInput {
  create: GrindCreateInput
  update: GrindUpdateDataInput
  upsert: GrindUpsertNestedInput
  connect: GrindWhereUniqueInput
}

input GrindUpsertNestedInput {
  update: GrindUpdateDataInput!
  create: GrindCreateInput!
}

input GrindWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  Ja: Boolean
  Ja_not: Boolean
  Nei: Boolean
  Nei_not: Boolean
  Espressomaskin: Boolean
  Espressomaskin_not: Boolean
  Espressokanne: Boolean
  Espressokanne_not: Boolean
  Aeropress: Boolean
  Aeropress_not: Boolean
  DryppV60: Boolean
  DryppV60_not: Boolean
  Filtermalt: Boolean
  Filtermalt_not: Boolean
  Presskanne: Boolean
  Presskanne_not: Boolean
  Chemex: Boolean
  Chemex_not: Boolean
  Kokmalt: Boolean
  Kokmalt_not: Boolean
  AND: [GrindWhereInput!]
  OR: [GrindWhereInput!]
  NOT: [GrindWhereInput!]
}

input GrindWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createCategory(data: CategoryCreateInput!): Category!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  createContentArea(data: ContentAreaCreateInput!): ContentArea!
  updateContentArea(data: ContentAreaUpdateInput!, where: ContentAreaWhereUniqueInput!): ContentArea
  updateManyContentAreas(data: ContentAreaUpdateManyMutationInput!, where: ContentAreaWhereInput): BatchPayload!
  upsertContentArea(where: ContentAreaWhereUniqueInput!, create: ContentAreaCreateInput!, update: ContentAreaUpdateInput!): ContentArea!
  deleteContentArea(where: ContentAreaWhereUniqueInput!): ContentArea
  deleteManyContentAreas(where: ContentAreaWhereInput): BatchPayload!
  createContentText(data: ContentTextCreateInput!): ContentText!
  updateContentText(data: ContentTextUpdateInput!, where: ContentTextWhereUniqueInput!): ContentText
  updateManyContentTexts(data: ContentTextUpdateManyMutationInput!, where: ContentTextWhereInput): BatchPayload!
  upsertContentText(where: ContentTextWhereUniqueInput!, create: ContentTextCreateInput!, update: ContentTextUpdateInput!): ContentText!
  deleteContentText(where: ContentTextWhereUniqueInput!): ContentText
  deleteManyContentTexts(where: ContentTextWhereInput): BatchPayload!
  createCountry(data: CountryCreateInput!): Country!
  updateCountry(data: CountryUpdateInput!, where: CountryWhereUniqueInput!): Country
  updateManyCountries(data: CountryUpdateManyMutationInput!, where: CountryWhereInput): BatchPayload!
  upsertCountry(where: CountryWhereUniqueInput!, create: CountryCreateInput!, update: CountryUpdateInput!): Country!
  deleteCountry(where: CountryWhereUniqueInput!): Country
  deleteManyCountries(where: CountryWhereInput): BatchPayload!
  createCustomer(data: CustomerCreateInput!): Customer!
  updateCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateManyCustomers(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): BatchPayload!
  upsertCustomer(where: CustomerWhereUniqueInput!, create: CustomerCreateInput!, update: CustomerUpdateInput!): Customer!
  deleteCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteManyCustomers(where: CustomerWhereInput): BatchPayload!
  createGrind(data: GrindCreateInput!): Grind!
  updateGrind(data: GrindUpdateInput!, where: GrindWhereUniqueInput!): Grind
  updateManyGrinds(data: GrindUpdateManyMutationInput!, where: GrindWhereInput): BatchPayload!
  upsertGrind(where: GrindWhereUniqueInput!, create: GrindCreateInput!, update: GrindUpdateInput!): Grind!
  deleteGrind(where: GrindWhereUniqueInput!): Grind
  deleteManyGrinds(where: GrindWhereInput): BatchPayload!
  createGrindOption(data: GrindOptionCreateInput!): GrindOption!
  updateGrindOption(data: GrindOptionUpdateInput!, where: GrindOptionWhereUniqueInput!): GrindOption
  upsertGrindOption(where: GrindOptionWhereUniqueInput!, create: GrindOptionCreateInput!, update: GrindOptionUpdateInput!): GrindOption!
  deleteGrindOption(where: GrindOptionWhereUniqueInput!): GrindOption
  deleteManyGrindOptions(where: GrindOptionWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateManyOrders(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createOrderLine(data: OrderLineCreateInput!): OrderLine!
  updateOrderLine(data: OrderLineUpdateInput!, where: OrderLineWhereUniqueInput!): OrderLine
  updateManyOrderLines(data: OrderLineUpdateManyMutationInput!, where: OrderLineWhereInput): BatchPayload!
  upsertOrderLine(where: OrderLineWhereUniqueInput!, create: OrderLineCreateInput!, update: OrderLineUpdateInput!): OrderLine!
  deleteOrderLine(where: OrderLineWhereUniqueInput!): OrderLine
  deleteManyOrderLines(where: OrderLineWhereInput): BatchPayload!
  createOrigin(data: OriginCreateInput!): Origin!
  updateOrigin(data: OriginUpdateInput!, where: OriginWhereUniqueInput!): Origin
  updateManyOrigins(data: OriginUpdateManyMutationInput!, where: OriginWhereInput): BatchPayload!
  upsertOrigin(where: OriginWhereUniqueInput!, create: OriginCreateInput!, update: OriginUpdateInput!): Origin!
  deleteOrigin(where: OriginWhereUniqueInput!): Origin
  deleteManyOrigins(where: OriginWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createProductImage(data: ProductImageCreateInput!): ProductImage!
  updateProductImage(data: ProductImageUpdateInput!, where: ProductImageWhereUniqueInput!): ProductImage
  updateManyProductImages(data: ProductImageUpdateManyMutationInput!, where: ProductImageWhereInput): BatchPayload!
  upsertProductImage(where: ProductImageWhereUniqueInput!, create: ProductImageCreateInput!, update: ProductImageUpdateInput!): ProductImage!
  deleteProductImage(where: ProductImageWhereUniqueInput!): ProductImage
  deleteManyProductImages(where: ProductImageWhereInput): BatchPayload!
  createRegion(data: RegionCreateInput!): Region!
  updateRegion(data: RegionUpdateInput!, where: RegionWhereUniqueInput!): Region
  updateManyRegions(data: RegionUpdateManyMutationInput!, where: RegionWhereInput): BatchPayload!
  upsertRegion(where: RegionWhereUniqueInput!, create: RegionCreateInput!, update: RegionUpdateInput!): Region!
  deleteRegion(where: RegionWhereUniqueInput!): Region
  deleteManyRegions(where: RegionWhereInput): BatchPayload!
  createReview(data: ReviewCreateInput!): Review!
  updateReview(data: ReviewUpdateInput!, where: ReviewWhereUniqueInput!): Review
  updateManyReviews(data: ReviewUpdateManyMutationInput!, where: ReviewWhereInput): BatchPayload!
  upsertReview(where: ReviewWhereUniqueInput!, create: ReviewCreateInput!, update: ReviewUpdateInput!): Review!
  deleteReview(where: ReviewWhereUniqueInput!): Review
  deleteManyReviews(where: ReviewWhereInput): BatchPayload!
  createSKU(data: SKUCreateInput!): SKU!
  updateSKU(data: SKUUpdateInput!, where: SKUWhereUniqueInput!): SKU
  updateManySKUs(data: SKUUpdateManyMutationInput!, where: SKUWhereInput): BatchPayload!
  upsertSKU(where: SKUWhereUniqueInput!, create: SKUCreateInput!, update: SKUUpdateInput!): SKU!
  deleteSKU(where: SKUWhereUniqueInput!): SKU
  deleteManySKUs(where: SKUWhereInput): BatchPayload!
  createSubCategory(data: SubCategoryCreateInput!): SubCategory!
  updateSubCategory(data: SubCategoryUpdateInput!, where: SubCategoryWhereUniqueInput!): SubCategory
  updateManySubCategories(data: SubCategoryUpdateManyMutationInput!, where: SubCategoryWhereInput): BatchPayload!
  upsertSubCategory(where: SubCategoryWhereUniqueInput!, create: SubCategoryCreateInput!, update: SubCategoryUpdateInput!): SubCategory!
  deleteSubCategory(where: SubCategoryWhereUniqueInput!): SubCategory
  deleteManySubCategories(where: SubCategoryWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createVendor(data: VendorCreateInput!): Vendor!
  updateVendor(data: VendorUpdateInput!, where: VendorWhereUniqueInput!): Vendor
  updateManyVendors(data: VendorUpdateManyMutationInput!, where: VendorWhereInput): BatchPayload!
  upsertVendor(where: VendorWhereUniqueInput!, create: VendorCreateInput!, update: VendorUpdateInput!): Vendor!
  deleteVendor(where: VendorWhereUniqueInput!): Vendor
  deleteManyVendors(where: VendorWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Order {
  id: ID!
  customer: Customer!
  vendor: Vendor!
  deliveryStatus: String
  orderData: DateTime!
  orderNote: String
  deliveryAddress: String!
  orderLines(where: OrderLineWhereInput, orderBy: OrderLineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderLine!]
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  id: ID
  customer: CustomerCreateOneInput!
  vendor: VendorCreateOneInput!
  deliveryStatus: String
  orderData: DateTime!
  orderNote: String
  deliveryAddress: String!
  orderLines: OrderLineCreateManyWithoutOrderInput
}

input OrderCreateOneWithoutOrderLinesInput {
  create: OrderCreateWithoutOrderLinesInput
  connect: OrderWhereUniqueInput
}

input OrderCreateWithoutOrderLinesInput {
  id: ID
  customer: CustomerCreateOneInput!
  vendor: VendorCreateOneInput!
  deliveryStatus: String
  orderData: DateTime!
  orderNote: String
  deliveryAddress: String!
}

type OrderEdge {
  node: Order!
  cursor: String!
}

type OrderLine {
  id: ID!
  order: Order!
  sku: SKU!
  productName: String!
  grindOption: String!
  quantity: Int!
  orderPrice: Float!
}

type OrderLineConnection {
  pageInfo: PageInfo!
  edges: [OrderLineEdge]!
  aggregate: AggregateOrderLine!
}

input OrderLineCreateInput {
  id: ID
  order: OrderCreateOneWithoutOrderLinesInput!
  sku: SKUCreateOneInput!
  productName: String!
  grindOption: String!
  quantity: Int!
  orderPrice: Float!
}

input OrderLineCreateManyWithoutOrderInput {
  create: [OrderLineCreateWithoutOrderInput!]
  connect: [OrderLineWhereUniqueInput!]
}

input OrderLineCreateWithoutOrderInput {
  id: ID
  sku: SKUCreateOneInput!
  productName: String!
  grindOption: String!
  quantity: Int!
  orderPrice: Float!
}

type OrderLineEdge {
  node: OrderLine!
  cursor: String!
}

enum OrderLineOrderByInput {
  id_ASC
  id_DESC
  productName_ASC
  productName_DESC
  grindOption_ASC
  grindOption_DESC
  quantity_ASC
  quantity_DESC
  orderPrice_ASC
  orderPrice_DESC
}

type OrderLinePreviousValues {
  id: ID!
  productName: String!
  grindOption: String!
  quantity: Int!
  orderPrice: Float!
}

input OrderLineScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  productName: String
  productName_not: String
  productName_in: [String!]
  productName_not_in: [String!]
  productName_lt: String
  productName_lte: String
  productName_gt: String
  productName_gte: String
  productName_contains: String
  productName_not_contains: String
  productName_starts_with: String
  productName_not_starts_with: String
  productName_ends_with: String
  productName_not_ends_with: String
  grindOption: String
  grindOption_not: String
  grindOption_in: [String!]
  grindOption_not_in: [String!]
  grindOption_lt: String
  grindOption_lte: String
  grindOption_gt: String
  grindOption_gte: String
  grindOption_contains: String
  grindOption_not_contains: String
  grindOption_starts_with: String
  grindOption_not_starts_with: String
  grindOption_ends_with: String
  grindOption_not_ends_with: String
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  orderPrice: Float
  orderPrice_not: Float
  orderPrice_in: [Float!]
  orderPrice_not_in: [Float!]
  orderPrice_lt: Float
  orderPrice_lte: Float
  orderPrice_gt: Float
  orderPrice_gte: Float
  AND: [OrderLineScalarWhereInput!]
  OR: [OrderLineScalarWhereInput!]
  NOT: [OrderLineScalarWhereInput!]
}

type OrderLineSubscriptionPayload {
  mutation: MutationType!
  node: OrderLine
  updatedFields: [String!]
  previousValues: OrderLinePreviousValues
}

input OrderLineSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderLineWhereInput
  AND: [OrderLineSubscriptionWhereInput!]
  OR: [OrderLineSubscriptionWhereInput!]
  NOT: [OrderLineSubscriptionWhereInput!]
}

input OrderLineUpdateInput {
  order: OrderUpdateOneRequiredWithoutOrderLinesInput
  sku: SKUUpdateOneRequiredInput
  productName: String
  grindOption: String
  quantity: Int
  orderPrice: Float
}

input OrderLineUpdateManyDataInput {
  productName: String
  grindOption: String
  quantity: Int
  orderPrice: Float
}

input OrderLineUpdateManyMutationInput {
  productName: String
  grindOption: String
  quantity: Int
  orderPrice: Float
}

input OrderLineUpdateManyWithoutOrderInput {
  create: [OrderLineCreateWithoutOrderInput!]
  delete: [OrderLineWhereUniqueInput!]
  connect: [OrderLineWhereUniqueInput!]
  set: [OrderLineWhereUniqueInput!]
  disconnect: [OrderLineWhereUniqueInput!]
  update: [OrderLineUpdateWithWhereUniqueWithoutOrderInput!]
  upsert: [OrderLineUpsertWithWhereUniqueWithoutOrderInput!]
  deleteMany: [OrderLineScalarWhereInput!]
  updateMany: [OrderLineUpdateManyWithWhereNestedInput!]
}

input OrderLineUpdateManyWithWhereNestedInput {
  where: OrderLineScalarWhereInput!
  data: OrderLineUpdateManyDataInput!
}

input OrderLineUpdateWithoutOrderDataInput {
  sku: SKUUpdateOneRequiredInput
  productName: String
  grindOption: String
  quantity: Int
  orderPrice: Float
}

input OrderLineUpdateWithWhereUniqueWithoutOrderInput {
  where: OrderLineWhereUniqueInput!
  data: OrderLineUpdateWithoutOrderDataInput!
}

input OrderLineUpsertWithWhereUniqueWithoutOrderInput {
  where: OrderLineWhereUniqueInput!
  update: OrderLineUpdateWithoutOrderDataInput!
  create: OrderLineCreateWithoutOrderInput!
}

input OrderLineWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  order: OrderWhereInput
  sku: SKUWhereInput
  productName: String
  productName_not: String
  productName_in: [String!]
  productName_not_in: [String!]
  productName_lt: String
  productName_lte: String
  productName_gt: String
  productName_gte: String
  productName_contains: String
  productName_not_contains: String
  productName_starts_with: String
  productName_not_starts_with: String
  productName_ends_with: String
  productName_not_ends_with: String
  grindOption: String
  grindOption_not: String
  grindOption_in: [String!]
  grindOption_not_in: [String!]
  grindOption_lt: String
  grindOption_lte: String
  grindOption_gt: String
  grindOption_gte: String
  grindOption_contains: String
  grindOption_not_contains: String
  grindOption_starts_with: String
  grindOption_not_starts_with: String
  grindOption_ends_with: String
  grindOption_not_ends_with: String
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  orderPrice: Float
  orderPrice_not: Float
  orderPrice_in: [Float!]
  orderPrice_not_in: [Float!]
  orderPrice_lt: Float
  orderPrice_lte: Float
  orderPrice_gt: Float
  orderPrice_gte: Float
  AND: [OrderLineWhereInput!]
  OR: [OrderLineWhereInput!]
  NOT: [OrderLineWhereInput!]
}

input OrderLineWhereUniqueInput {
  id: ID
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
  deliveryStatus_ASC
  deliveryStatus_DESC
  orderData_ASC
  orderData_DESC
  orderNote_ASC
  orderNote_DESC
  deliveryAddress_ASC
  deliveryAddress_DESC
}

type OrderPreviousValues {
  id: ID!
  deliveryStatus: String
  orderData: DateTime!
  orderNote: String
  deliveryAddress: String!
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderUpdateInput {
  customer: CustomerUpdateOneRequiredInput
  vendor: VendorUpdateOneRequiredInput
  deliveryStatus: String
  orderData: DateTime
  orderNote: String
  deliveryAddress: String
  orderLines: OrderLineUpdateManyWithoutOrderInput
}

input OrderUpdateManyMutationInput {
  deliveryStatus: String
  orderData: DateTime
  orderNote: String
  deliveryAddress: String
}

input OrderUpdateOneRequiredWithoutOrderLinesInput {
  create: OrderCreateWithoutOrderLinesInput
  update: OrderUpdateWithoutOrderLinesDataInput
  upsert: OrderUpsertWithoutOrderLinesInput
  connect: OrderWhereUniqueInput
}

input OrderUpdateWithoutOrderLinesDataInput {
  customer: CustomerUpdateOneRequiredInput
  vendor: VendorUpdateOneRequiredInput
  deliveryStatus: String
  orderData: DateTime
  orderNote: String
  deliveryAddress: String
}

input OrderUpsertWithoutOrderLinesInput {
  update: OrderUpdateWithoutOrderLinesDataInput!
  create: OrderCreateWithoutOrderLinesInput!
}

input OrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  customer: CustomerWhereInput
  vendor: VendorWhereInput
  deliveryStatus: String
  deliveryStatus_not: String
  deliveryStatus_in: [String!]
  deliveryStatus_not_in: [String!]
  deliveryStatus_lt: String
  deliveryStatus_lte: String
  deliveryStatus_gt: String
  deliveryStatus_gte: String
  deliveryStatus_contains: String
  deliveryStatus_not_contains: String
  deliveryStatus_starts_with: String
  deliveryStatus_not_starts_with: String
  deliveryStatus_ends_with: String
  deliveryStatus_not_ends_with: String
  orderData: DateTime
  orderData_not: DateTime
  orderData_in: [DateTime!]
  orderData_not_in: [DateTime!]
  orderData_lt: DateTime
  orderData_lte: DateTime
  orderData_gt: DateTime
  orderData_gte: DateTime
  orderNote: String
  orderNote_not: String
  orderNote_in: [String!]
  orderNote_not_in: [String!]
  orderNote_lt: String
  orderNote_lte: String
  orderNote_gt: String
  orderNote_gte: String
  orderNote_contains: String
  orderNote_not_contains: String
  orderNote_starts_with: String
  orderNote_not_starts_with: String
  orderNote_ends_with: String
  orderNote_not_ends_with: String
  deliveryAddress: String
  deliveryAddress_not: String
  deliveryAddress_in: [String!]
  deliveryAddress_not_in: [String!]
  deliveryAddress_lt: String
  deliveryAddress_lte: String
  deliveryAddress_gt: String
  deliveryAddress_gte: String
  deliveryAddress_contains: String
  deliveryAddress_not_contains: String
  deliveryAddress_starts_with: String
  deliveryAddress_not_starts_with: String
  deliveryAddress_ends_with: String
  deliveryAddress_not_ends_with: String
  orderLines_every: OrderLineWhereInput
  orderLines_some: OrderLineWhereInput
  orderLines_none: OrderLineWhereInput
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: ID
}

type Origin {
  id: ID!
  name: String!
  regions(where: RegionWhereInput, orderBy: RegionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Region!]
}

type OriginConnection {
  pageInfo: PageInfo!
  edges: [OriginEdge]!
  aggregate: AggregateOrigin!
}

input OriginCreateInput {
  id: ID
  name: String!
  regions: RegionCreateManyInput
}

type OriginEdge {
  node: Origin!
  cursor: String!
}

enum OriginOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type OriginPreviousValues {
  id: ID!
  name: String!
}

type OriginSubscriptionPayload {
  mutation: MutationType!
  node: Origin
  updatedFields: [String!]
  previousValues: OriginPreviousValues
}

input OriginSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OriginWhereInput
  AND: [OriginSubscriptionWhereInput!]
  OR: [OriginSubscriptionWhereInput!]
  NOT: [OriginSubscriptionWhereInput!]
}

input OriginUpdateInput {
  name: String
  regions: RegionUpdateManyInput
}

input OriginUpdateManyMutationInput {
  name: String
}

input OriginWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  regions_every: RegionWhereInput
  regions_some: RegionWhereInput
  regions_none: RegionWhereInput
  AND: [OriginWhereInput!]
  OR: [OriginWhereInput!]
  NOT: [OriginWhereInput!]
}

input OriginWhereUniqueInput {
  id: ID
  name: String
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Product {
  id: ID!
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean!
  vendor: Vendor
  country: Country
  productImages(where: ProductImageWhereInput, orderBy: ProductImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductImage!]
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category!]
  skus(where: SKUWhereInput, orderBy: SKUOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SKU!]
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: ID
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean
  vendor: VendorCreateOneWithoutProductsInput
  country: CountryCreateOneWithoutProductsInput
  productImages: ProductImageCreateManyWithoutProductInput
  categories: CategoryCreateManyWithoutProductsInput
  skus: SKUCreateManyWithoutProductInput
}

input ProductCreateManyWithoutCountryInput {
  create: [ProductCreateWithoutCountryInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateManyWithoutVendorInput {
  create: [ProductCreateWithoutVendorInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateOneInput {
  create: ProductCreateInput
  connect: ProductWhereUniqueInput
}

input ProductCreateOneWithoutCategoriesInput {
  create: ProductCreateWithoutCategoriesInput
  connect: ProductWhereUniqueInput
}

input ProductCreateOneWithoutProductImagesInput {
  create: ProductCreateWithoutProductImagesInput
  connect: ProductWhereUniqueInput
}

input ProductCreateOneWithoutSkusInput {
  create: ProductCreateWithoutSkusInput
  connect: ProductWhereUniqueInput
}

input ProductCreateWithoutCategoriesInput {
  id: ID
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean
  vendor: VendorCreateOneWithoutProductsInput
  country: CountryCreateOneWithoutProductsInput
  productImages: ProductImageCreateManyWithoutProductInput
  skus: SKUCreateManyWithoutProductInput
}

input ProductCreateWithoutCountryInput {
  id: ID
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean
  vendor: VendorCreateOneWithoutProductsInput
  productImages: ProductImageCreateManyWithoutProductInput
  categories: CategoryCreateManyWithoutProductsInput
  skus: SKUCreateManyWithoutProductInput
}

input ProductCreateWithoutProductImagesInput {
  id: ID
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean
  vendor: VendorCreateOneWithoutProductsInput
  country: CountryCreateOneWithoutProductsInput
  categories: CategoryCreateManyWithoutProductsInput
  skus: SKUCreateManyWithoutProductInput
}

input ProductCreateWithoutSkusInput {
  id: ID
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean
  vendor: VendorCreateOneWithoutProductsInput
  country: CountryCreateOneWithoutProductsInput
  productImages: ProductImageCreateManyWithoutProductInput
  categories: CategoryCreateManyWithoutProductsInput
}

input ProductCreateWithoutVendorInput {
  id: ID
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean
  country: CountryCreateOneWithoutProductsInput
  productImages: ProductImageCreateManyWithoutProductInput
  categories: CategoryCreateManyWithoutProductsInput
  skus: SKUCreateManyWithoutProductInput
}

type ProductEdge {
  node: Product!
  cursor: String!
}

type ProductImage {
  id: ID!
  image: String!
  product: Product
}

type ProductImageConnection {
  pageInfo: PageInfo!
  edges: [ProductImageEdge]!
  aggregate: AggregateProductImage!
}

input ProductImageCreateInput {
  id: ID
  image: String!
  product: ProductCreateOneWithoutProductImagesInput
}

input ProductImageCreateManyWithoutProductInput {
  create: [ProductImageCreateWithoutProductInput!]
  connect: [ProductImageWhereUniqueInput!]
}

input ProductImageCreateWithoutProductInput {
  id: ID
  image: String!
}

type ProductImageEdge {
  node: ProductImage!
  cursor: String!
}

enum ProductImageOrderByInput {
  id_ASC
  id_DESC
  image_ASC
  image_DESC
}

type ProductImagePreviousValues {
  id: ID!
  image: String!
}

input ProductImageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  AND: [ProductImageScalarWhereInput!]
  OR: [ProductImageScalarWhereInput!]
  NOT: [ProductImageScalarWhereInput!]
}

type ProductImageSubscriptionPayload {
  mutation: MutationType!
  node: ProductImage
  updatedFields: [String!]
  previousValues: ProductImagePreviousValues
}

input ProductImageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductImageWhereInput
  AND: [ProductImageSubscriptionWhereInput!]
  OR: [ProductImageSubscriptionWhereInput!]
  NOT: [ProductImageSubscriptionWhereInput!]
}

input ProductImageUpdateInput {
  image: String
  product: ProductUpdateOneWithoutProductImagesInput
}

input ProductImageUpdateManyDataInput {
  image: String
}

input ProductImageUpdateManyMutationInput {
  image: String
}

input ProductImageUpdateManyWithoutProductInput {
  create: [ProductImageCreateWithoutProductInput!]
  delete: [ProductImageWhereUniqueInput!]
  connect: [ProductImageWhereUniqueInput!]
  set: [ProductImageWhereUniqueInput!]
  disconnect: [ProductImageWhereUniqueInput!]
  update: [ProductImageUpdateWithWhereUniqueWithoutProductInput!]
  upsert: [ProductImageUpsertWithWhereUniqueWithoutProductInput!]
  deleteMany: [ProductImageScalarWhereInput!]
  updateMany: [ProductImageUpdateManyWithWhereNestedInput!]
}

input ProductImageUpdateManyWithWhereNestedInput {
  where: ProductImageScalarWhereInput!
  data: ProductImageUpdateManyDataInput!
}

input ProductImageUpdateWithoutProductDataInput {
  image: String
}

input ProductImageUpdateWithWhereUniqueWithoutProductInput {
  where: ProductImageWhereUniqueInput!
  data: ProductImageUpdateWithoutProductDataInput!
}

input ProductImageUpsertWithWhereUniqueWithoutProductInput {
  where: ProductImageWhereUniqueInput!
  update: ProductImageUpdateWithoutProductDataInput!
  create: ProductImageCreateWithoutProductInput!
}

input ProductImageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  product: ProductWhereInput
  AND: [ProductImageWhereInput!]
  OR: [ProductImageWhereInput!]
  NOT: [ProductImageWhereInput!]
}

input ProductImageWhereUniqueInput {
  id: ID
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  flavorProfile_ASC
  flavorProfile_DESC
  descriptionShort_ASC
  descriptionShort_DESC
  descriptionLong_ASC
  descriptionLong_DESC
  brewText_ASC
  brewText_DESC
  published_ASC
  published_DESC
}

type ProductPreviousValues {
  id: ID!
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean!
}

input ProductScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  flavorProfile: String
  flavorProfile_not: String
  flavorProfile_in: [String!]
  flavorProfile_not_in: [String!]
  flavorProfile_lt: String
  flavorProfile_lte: String
  flavorProfile_gt: String
  flavorProfile_gte: String
  flavorProfile_contains: String
  flavorProfile_not_contains: String
  flavorProfile_starts_with: String
  flavorProfile_not_starts_with: String
  flavorProfile_ends_with: String
  flavorProfile_not_ends_with: String
  descriptionShort: String
  descriptionShort_not: String
  descriptionShort_in: [String!]
  descriptionShort_not_in: [String!]
  descriptionShort_lt: String
  descriptionShort_lte: String
  descriptionShort_gt: String
  descriptionShort_gte: String
  descriptionShort_contains: String
  descriptionShort_not_contains: String
  descriptionShort_starts_with: String
  descriptionShort_not_starts_with: String
  descriptionShort_ends_with: String
  descriptionShort_not_ends_with: String
  descriptionLong: String
  descriptionLong_not: String
  descriptionLong_in: [String!]
  descriptionLong_not_in: [String!]
  descriptionLong_lt: String
  descriptionLong_lte: String
  descriptionLong_gt: String
  descriptionLong_gte: String
  descriptionLong_contains: String
  descriptionLong_not_contains: String
  descriptionLong_starts_with: String
  descriptionLong_not_starts_with: String
  descriptionLong_ends_with: String
  descriptionLong_not_ends_with: String
  brewText: String
  brewText_not: String
  brewText_in: [String!]
  brewText_not_in: [String!]
  brewText_lt: String
  brewText_lte: String
  brewText_gt: String
  brewText_gte: String
  brewText_contains: String
  brewText_not_contains: String
  brewText_starts_with: String
  brewText_not_starts_with: String
  brewText_ends_with: String
  brewText_not_ends_with: String
  published: Boolean
  published_not: Boolean
  AND: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  NOT: [ProductScalarWhereInput!]
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateDataInput {
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean
  vendor: VendorUpdateOneWithoutProductsInput
  country: CountryUpdateOneWithoutProductsInput
  productImages: ProductImageUpdateManyWithoutProductInput
  categories: CategoryUpdateManyWithoutProductsInput
  skus: SKUUpdateManyWithoutProductInput
}

input ProductUpdateInput {
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean
  vendor: VendorUpdateOneWithoutProductsInput
  country: CountryUpdateOneWithoutProductsInput
  productImages: ProductImageUpdateManyWithoutProductInput
  categories: CategoryUpdateManyWithoutProductsInput
  skus: SKUUpdateManyWithoutProductInput
}

input ProductUpdateManyDataInput {
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean
}

input ProductUpdateManyMutationInput {
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean
}

input ProductUpdateManyWithoutCountryInput {
  create: [ProductCreateWithoutCountryInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutCountryInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutCountryInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithoutVendorInput {
  create: [ProductCreateWithoutVendorInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutVendorInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutVendorInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput!
  data: ProductUpdateManyDataInput!
}

input ProductUpdateOneRequiredInput {
  create: ProductCreateInput
  update: ProductUpdateDataInput
  upsert: ProductUpsertNestedInput
  connect: ProductWhereUniqueInput
}

input ProductUpdateOneRequiredWithoutCategoriesInput {
  create: ProductCreateWithoutCategoriesInput
  update: ProductUpdateWithoutCategoriesDataInput
  upsert: ProductUpsertWithoutCategoriesInput
  connect: ProductWhereUniqueInput
}

input ProductUpdateOneRequiredWithoutSkusInput {
  create: ProductCreateWithoutSkusInput
  update: ProductUpdateWithoutSkusDataInput
  upsert: ProductUpsertWithoutSkusInput
  connect: ProductWhereUniqueInput
}

input ProductUpdateOneWithoutProductImagesInput {
  create: ProductCreateWithoutProductImagesInput
  update: ProductUpdateWithoutProductImagesDataInput
  upsert: ProductUpsertWithoutProductImagesInput
  delete: Boolean
  disconnect: Boolean
  connect: ProductWhereUniqueInput
}

input ProductUpdateWithoutCategoriesDataInput {
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean
  vendor: VendorUpdateOneWithoutProductsInput
  country: CountryUpdateOneWithoutProductsInput
  productImages: ProductImageUpdateManyWithoutProductInput
  skus: SKUUpdateManyWithoutProductInput
}

input ProductUpdateWithoutCountryDataInput {
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean
  vendor: VendorUpdateOneWithoutProductsInput
  productImages: ProductImageUpdateManyWithoutProductInput
  categories: CategoryUpdateManyWithoutProductsInput
  skus: SKUUpdateManyWithoutProductInput
}

input ProductUpdateWithoutProductImagesDataInput {
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean
  vendor: VendorUpdateOneWithoutProductsInput
  country: CountryUpdateOneWithoutProductsInput
  categories: CategoryUpdateManyWithoutProductsInput
  skus: SKUUpdateManyWithoutProductInput
}

input ProductUpdateWithoutSkusDataInput {
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean
  vendor: VendorUpdateOneWithoutProductsInput
  country: CountryUpdateOneWithoutProductsInput
  productImages: ProductImageUpdateManyWithoutProductInput
  categories: CategoryUpdateManyWithoutProductsInput
}

input ProductUpdateWithoutVendorDataInput {
  title: String
  flavorProfile: String
  descriptionShort: String
  descriptionLong: String
  brewText: String
  published: Boolean
  country: CountryUpdateOneWithoutProductsInput
  productImages: ProductImageUpdateManyWithoutProductInput
  categories: CategoryUpdateManyWithoutProductsInput
  skus: SKUUpdateManyWithoutProductInput
}

input ProductUpdateWithWhereUniqueWithoutCountryInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutCountryDataInput!
}

input ProductUpdateWithWhereUniqueWithoutVendorInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutVendorDataInput!
}

input ProductUpsertNestedInput {
  update: ProductUpdateDataInput!
  create: ProductCreateInput!
}

input ProductUpsertWithoutCategoriesInput {
  update: ProductUpdateWithoutCategoriesDataInput!
  create: ProductCreateWithoutCategoriesInput!
}

input ProductUpsertWithoutProductImagesInput {
  update: ProductUpdateWithoutProductImagesDataInput!
  create: ProductCreateWithoutProductImagesInput!
}

input ProductUpsertWithoutSkusInput {
  update: ProductUpdateWithoutSkusDataInput!
  create: ProductCreateWithoutSkusInput!
}

input ProductUpsertWithWhereUniqueWithoutCountryInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutCountryDataInput!
  create: ProductCreateWithoutCountryInput!
}

input ProductUpsertWithWhereUniqueWithoutVendorInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutVendorDataInput!
  create: ProductCreateWithoutVendorInput!
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  flavorProfile: String
  flavorProfile_not: String
  flavorProfile_in: [String!]
  flavorProfile_not_in: [String!]
  flavorProfile_lt: String
  flavorProfile_lte: String
  flavorProfile_gt: String
  flavorProfile_gte: String
  flavorProfile_contains: String
  flavorProfile_not_contains: String
  flavorProfile_starts_with: String
  flavorProfile_not_starts_with: String
  flavorProfile_ends_with: String
  flavorProfile_not_ends_with: String
  descriptionShort: String
  descriptionShort_not: String
  descriptionShort_in: [String!]
  descriptionShort_not_in: [String!]
  descriptionShort_lt: String
  descriptionShort_lte: String
  descriptionShort_gt: String
  descriptionShort_gte: String
  descriptionShort_contains: String
  descriptionShort_not_contains: String
  descriptionShort_starts_with: String
  descriptionShort_not_starts_with: String
  descriptionShort_ends_with: String
  descriptionShort_not_ends_with: String
  descriptionLong: String
  descriptionLong_not: String
  descriptionLong_in: [String!]
  descriptionLong_not_in: [String!]
  descriptionLong_lt: String
  descriptionLong_lte: String
  descriptionLong_gt: String
  descriptionLong_gte: String
  descriptionLong_contains: String
  descriptionLong_not_contains: String
  descriptionLong_starts_with: String
  descriptionLong_not_starts_with: String
  descriptionLong_ends_with: String
  descriptionLong_not_ends_with: String
  brewText: String
  brewText_not: String
  brewText_in: [String!]
  brewText_not_in: [String!]
  brewText_lt: String
  brewText_lte: String
  brewText_gt: String
  brewText_gte: String
  brewText_contains: String
  brewText_not_contains: String
  brewText_starts_with: String
  brewText_not_starts_with: String
  brewText_ends_with: String
  brewText_not_ends_with: String
  published: Boolean
  published_not: Boolean
  vendor: VendorWhereInput
  country: CountryWhereInput
  productImages_every: ProductImageWhereInput
  productImages_some: ProductImageWhereInput
  productImages_none: ProductImageWhereInput
  categories_every: CategoryWhereInput
  categories_some: CategoryWhereInput
  categories_none: CategoryWhereInput
  skus_every: SKUWhereInput
  skus_some: SKUWhereInput
  skus_none: SKUWhereInput
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
}

type Query {
  category(where: CategoryWhereUniqueInput!): Category
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  contentArea(where: ContentAreaWhereUniqueInput!): ContentArea
  contentAreas(where: ContentAreaWhereInput, orderBy: ContentAreaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContentArea]!
  contentAreasConnection(where: ContentAreaWhereInput, orderBy: ContentAreaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContentAreaConnection!
  contentText(where: ContentTextWhereUniqueInput!): ContentText
  contentTexts(where: ContentTextWhereInput, orderBy: ContentTextOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContentText]!
  contentTextsConnection(where: ContentTextWhereInput, orderBy: ContentTextOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContentTextConnection!
  country(where: CountryWhereUniqueInput!): Country
  countries(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Country]!
  countriesConnection(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CountryConnection!
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer]!
  customersConnection(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerConnection!
  grind(where: GrindWhereUniqueInput!): Grind
  grinds(where: GrindWhereInput, orderBy: GrindOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Grind]!
  grindsConnection(where: GrindWhereInput, orderBy: GrindOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GrindConnection!
  grindOption(where: GrindOptionWhereUniqueInput!): GrindOption
  grindOptions(where: GrindOptionWhereInput, orderBy: GrindOptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GrindOption]!
  grindOptionsConnection(where: GrindOptionWhereInput, orderBy: GrindOptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GrindOptionConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  orderLine(where: OrderLineWhereUniqueInput!): OrderLine
  orderLines(where: OrderLineWhereInput, orderBy: OrderLineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderLine]!
  orderLinesConnection(where: OrderLineWhereInput, orderBy: OrderLineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderLineConnection!
  origin(where: OriginWhereUniqueInput!): Origin
  origins(where: OriginWhereInput, orderBy: OriginOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Origin]!
  originsConnection(where: OriginWhereInput, orderBy: OriginOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OriginConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  productImage(where: ProductImageWhereUniqueInput!): ProductImage
  productImages(where: ProductImageWhereInput, orderBy: ProductImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductImage]!
  productImagesConnection(where: ProductImageWhereInput, orderBy: ProductImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductImageConnection!
  region(where: RegionWhereUniqueInput!): Region
  regions(where: RegionWhereInput, orderBy: RegionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Region]!
  regionsConnection(where: RegionWhereInput, orderBy: RegionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RegionConnection!
  review(where: ReviewWhereUniqueInput!): Review
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review]!
  reviewsConnection(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReviewConnection!
  sKU(where: SKUWhereUniqueInput!): SKU
  sKUs(where: SKUWhereInput, orderBy: SKUOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SKU]!
  sKUsConnection(where: SKUWhereInput, orderBy: SKUOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SKUConnection!
  subCategory(where: SubCategoryWhereUniqueInput!): SubCategory
  subCategories(where: SubCategoryWhereInput, orderBy: SubCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubCategory]!
  subCategoriesConnection(where: SubCategoryWhereInput, orderBy: SubCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubCategoryConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  vendor(where: VendorWhereUniqueInput!): Vendor
  vendors(where: VendorWhereInput, orderBy: VendorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vendor]!
  vendorsConnection(where: VendorWhereInput, orderBy: VendorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VendorConnection!
  node(id: ID!): Node
}

type Region {
  id: ID!
  name: String!
  countries(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Country!]
}

type RegionConnection {
  pageInfo: PageInfo!
  edges: [RegionEdge]!
  aggregate: AggregateRegion!
}

input RegionCreateInput {
  id: ID
  name: String!
  countries: CountryCreateManyWithoutRegionInput
}

input RegionCreateManyInput {
  create: [RegionCreateInput!]
  connect: [RegionWhereUniqueInput!]
}

input RegionCreateOneWithoutCountriesInput {
  create: RegionCreateWithoutCountriesInput
  connect: RegionWhereUniqueInput
}

input RegionCreateWithoutCountriesInput {
  id: ID
  name: String!
}

type RegionEdge {
  node: Region!
  cursor: String!
}

enum RegionOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type RegionPreviousValues {
  id: ID!
  name: String!
}

input RegionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [RegionScalarWhereInput!]
  OR: [RegionScalarWhereInput!]
  NOT: [RegionScalarWhereInput!]
}

type RegionSubscriptionPayload {
  mutation: MutationType!
  node: Region
  updatedFields: [String!]
  previousValues: RegionPreviousValues
}

input RegionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RegionWhereInput
  AND: [RegionSubscriptionWhereInput!]
  OR: [RegionSubscriptionWhereInput!]
  NOT: [RegionSubscriptionWhereInput!]
}

input RegionUpdateDataInput {
  name: String
  countries: CountryUpdateManyWithoutRegionInput
}

input RegionUpdateInput {
  name: String
  countries: CountryUpdateManyWithoutRegionInput
}

input RegionUpdateManyDataInput {
  name: String
}

input RegionUpdateManyInput {
  create: [RegionCreateInput!]
  update: [RegionUpdateWithWhereUniqueNestedInput!]
  upsert: [RegionUpsertWithWhereUniqueNestedInput!]
  delete: [RegionWhereUniqueInput!]
  connect: [RegionWhereUniqueInput!]
  set: [RegionWhereUniqueInput!]
  disconnect: [RegionWhereUniqueInput!]
  deleteMany: [RegionScalarWhereInput!]
  updateMany: [RegionUpdateManyWithWhereNestedInput!]
}

input RegionUpdateManyMutationInput {
  name: String
}

input RegionUpdateManyWithWhereNestedInput {
  where: RegionScalarWhereInput!
  data: RegionUpdateManyDataInput!
}

input RegionUpdateOneWithoutCountriesInput {
  create: RegionCreateWithoutCountriesInput
  update: RegionUpdateWithoutCountriesDataInput
  upsert: RegionUpsertWithoutCountriesInput
  delete: Boolean
  disconnect: Boolean
  connect: RegionWhereUniqueInput
}

input RegionUpdateWithoutCountriesDataInput {
  name: String
}

input RegionUpdateWithWhereUniqueNestedInput {
  where: RegionWhereUniqueInput!
  data: RegionUpdateDataInput!
}

input RegionUpsertWithoutCountriesInput {
  update: RegionUpdateWithoutCountriesDataInput!
  create: RegionCreateWithoutCountriesInput!
}

input RegionUpsertWithWhereUniqueNestedInput {
  where: RegionWhereUniqueInput!
  update: RegionUpdateDataInput!
  create: RegionCreateInput!
}

input RegionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  countries_every: CountryWhereInput
  countries_some: CountryWhereInput
  countries_none: CountryWhereInput
  AND: [RegionWhereInput!]
  OR: [RegionWhereInput!]
  NOT: [RegionWhereInput!]
}

input RegionWhereUniqueInput {
  id: ID
  name: String
}

type Review {
  id: ID!
  customer: Customer!
  product: Product!
  rating: Int!
  title: String
  content: String
  publishedStatus: Boolean!
}

type ReviewConnection {
  pageInfo: PageInfo!
  edges: [ReviewEdge]!
  aggregate: AggregateReview!
}

input ReviewCreateInput {
  id: ID
  customer: CustomerCreateOneInput!
  product: ProductCreateOneInput!
  rating: Int!
  title: String
  content: String
  publishedStatus: Boolean
}

type ReviewEdge {
  node: Review!
  cursor: String!
}

enum ReviewOrderByInput {
  id_ASC
  id_DESC
  rating_ASC
  rating_DESC
  title_ASC
  title_DESC
  content_ASC
  content_DESC
  publishedStatus_ASC
  publishedStatus_DESC
}

type ReviewPreviousValues {
  id: ID!
  rating: Int!
  title: String
  content: String
  publishedStatus: Boolean!
}

type ReviewSubscriptionPayload {
  mutation: MutationType!
  node: Review
  updatedFields: [String!]
  previousValues: ReviewPreviousValues
}

input ReviewSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReviewWhereInput
  AND: [ReviewSubscriptionWhereInput!]
  OR: [ReviewSubscriptionWhereInput!]
  NOT: [ReviewSubscriptionWhereInput!]
}

input ReviewUpdateInput {
  customer: CustomerUpdateOneRequiredInput
  product: ProductUpdateOneRequiredInput
  rating: Int
  title: String
  content: String
  publishedStatus: Boolean
}

input ReviewUpdateManyMutationInput {
  rating: Int
  title: String
  content: String
  publishedStatus: Boolean
}

input ReviewWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  customer: CustomerWhereInput
  product: ProductWhereInput
  rating: Int
  rating_not: Int
  rating_in: [Int!]
  rating_not_in: [Int!]
  rating_lt: Int
  rating_lte: Int
  rating_gt: Int
  rating_gte: Int
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  publishedStatus: Boolean
  publishedStatus_not: Boolean
  AND: [ReviewWhereInput!]
  OR: [ReviewWhereInput!]
  NOT: [ReviewWhereInput!]
}

input ReviewWhereUniqueInput {
  id: ID
}

type SKU {
  id: ID!
  product: Product!
  grindOptions: Grind
  weight: String!
  price: String!
}

type SKUConnection {
  pageInfo: PageInfo!
  edges: [SKUEdge]!
  aggregate: AggregateSKU!
}

input SKUCreateInput {
  id: ID
  product: ProductCreateOneWithoutSkusInput!
  grindOptions: GrindCreateOneInput
  weight: String!
  price: String!
}

input SKUCreateManyWithoutProductInput {
  create: [SKUCreateWithoutProductInput!]
  connect: [SKUWhereUniqueInput!]
}

input SKUCreateOneInput {
  create: SKUCreateInput
  connect: SKUWhereUniqueInput
}

input SKUCreateWithoutProductInput {
  id: ID
  grindOptions: GrindCreateInput
  weight: String!
  price: String!
}

type SKUEdge {
  node: SKU!
  cursor: String!
}

enum SKUOrderByInput {
  id_ASC
  id_DESC
  weight_ASC
  weight_DESC
  price_ASC
  price_DESC
}

type SKUPreviousValues {
  id: ID!
  weight: String!
  price: String!
}

input SKUScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  weight: String
  weight_not: String
  weight_in: [String!]
  weight_not_in: [String!]
  weight_lt: String
  weight_lte: String
  weight_gt: String
  weight_gte: String
  weight_contains: String
  weight_not_contains: String
  weight_starts_with: String
  weight_not_starts_with: String
  weight_ends_with: String
  weight_not_ends_with: String
  price: String
  price_not: String
  price_in: [String!]
  price_not_in: [String!]
  price_lt: String
  price_lte: String
  price_gt: String
  price_gte: String
  price_contains: String
  price_not_contains: String
  price_starts_with: String
  price_not_starts_with: String
  price_ends_with: String
  price_not_ends_with: String
  AND: [SKUScalarWhereInput!]
  OR: [SKUScalarWhereInput!]
  NOT: [SKUScalarWhereInput!]
}

type SKUSubscriptionPayload {
  mutation: MutationType!
  node: SKU
  updatedFields: [String!]
  previousValues: SKUPreviousValues
}

input SKUSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SKUWhereInput
  AND: [SKUSubscriptionWhereInput!]
  OR: [SKUSubscriptionWhereInput!]
  NOT: [SKUSubscriptionWhereInput!]
}

input SKUUpdateDataInput {
  product: ProductUpdateOneRequiredWithoutSkusInput
  grindOptions: GrindUpdateOneInput
  weight: String
  price: String
}

input SKUUpdateInput {
  product: ProductUpdateOneRequiredWithoutSkusInput
  grindOptions: GrindUpdateOneInput
  weight: String
  price: String
}

input SKUUpdateManyDataInput {
  weight: String
  price: String
}

input SKUUpdateManyMutationInput {
  weight: String
  price: String
}

input SKUUpdateManyWithoutProductInput {
  create: [SKUCreateWithoutProductInput!]
  delete: [SKUWhereUniqueInput!]
  connect: [SKUWhereUniqueInput!]
  set: [SKUWhereUniqueInput!]
  disconnect: [SKUWhereUniqueInput!]
  update: [SKUUpdateWithWhereUniqueWithoutProductInput!]
  upsert: [SKUUpsertWithWhereUniqueWithoutProductInput!]
  deleteMany: [SKUScalarWhereInput!]
  updateMany: [SKUUpdateManyWithWhereNestedInput!]
}

input SKUUpdateManyWithWhereNestedInput {
  where: SKUScalarWhereInput!
  data: SKUUpdateManyDataInput!
}

input SKUUpdateOneRequiredInput {
  create: SKUCreateInput
  update: SKUUpdateDataInput
  upsert: SKUUpsertNestedInput
  connect: SKUWhereUniqueInput
}

input SKUUpdateWithoutProductDataInput {
  grindOptions: GrindUpdateOneInput
  weight: String
  price: String
}

input SKUUpdateWithWhereUniqueWithoutProductInput {
  where: SKUWhereUniqueInput!
  data: SKUUpdateWithoutProductDataInput!
}

input SKUUpsertNestedInput {
  update: SKUUpdateDataInput!
  create: SKUCreateInput!
}

input SKUUpsertWithWhereUniqueWithoutProductInput {
  where: SKUWhereUniqueInput!
  update: SKUUpdateWithoutProductDataInput!
  create: SKUCreateWithoutProductInput!
}

input SKUWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  product: ProductWhereInput
  grindOptions: GrindWhereInput
  weight: String
  weight_not: String
  weight_in: [String!]
  weight_not_in: [String!]
  weight_lt: String
  weight_lte: String
  weight_gt: String
  weight_gte: String
  weight_contains: String
  weight_not_contains: String
  weight_starts_with: String
  weight_not_starts_with: String
  weight_ends_with: String
  weight_not_ends_with: String
  price: String
  price_not: String
  price_in: [String!]
  price_not_in: [String!]
  price_lt: String
  price_lte: String
  price_gt: String
  price_gte: String
  price_contains: String
  price_not_contains: String
  price_starts_with: String
  price_not_starts_with: String
  price_ends_with: String
  price_not_ends_with: String
  AND: [SKUWhereInput!]
  OR: [SKUWhereInput!]
  NOT: [SKUWhereInput!]
}

input SKUWhereUniqueInput {
  id: ID
}

type SubCategory {
  id: ID!
  category: Category!
  subCategory: String!
}

type SubCategoryConnection {
  pageInfo: PageInfo!
  edges: [SubCategoryEdge]!
  aggregate: AggregateSubCategory!
}

input SubCategoryCreateInput {
  id: ID
  category: CategoryCreateOneInput!
  subCategory: String!
}

type SubCategoryEdge {
  node: SubCategory!
  cursor: String!
}

enum SubCategoryOrderByInput {
  id_ASC
  id_DESC
  subCategory_ASC
  subCategory_DESC
}

type SubCategoryPreviousValues {
  id: ID!
  subCategory: String!
}

type SubCategorySubscriptionPayload {
  mutation: MutationType!
  node: SubCategory
  updatedFields: [String!]
  previousValues: SubCategoryPreviousValues
}

input SubCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubCategoryWhereInput
  AND: [SubCategorySubscriptionWhereInput!]
  OR: [SubCategorySubscriptionWhereInput!]
  NOT: [SubCategorySubscriptionWhereInput!]
}

input SubCategoryUpdateInput {
  category: CategoryUpdateOneRequiredInput
  subCategory: String
}

input SubCategoryUpdateManyMutationInput {
  subCategory: String
}

input SubCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  category: CategoryWhereInput
  subCategory: String
  subCategory_not: String
  subCategory_in: [String!]
  subCategory_not_in: [String!]
  subCategory_lt: String
  subCategory_lte: String
  subCategory_gt: String
  subCategory_gte: String
  subCategory_contains: String
  subCategory_not_contains: String
  subCategory_starts_with: String
  subCategory_not_starts_with: String
  subCategory_ends_with: String
  subCategory_not_ends_with: String
  AND: [SubCategoryWhereInput!]
  OR: [SubCategoryWhereInput!]
  NOT: [SubCategoryWhereInput!]
}

input SubCategoryWhereUniqueInput {
  id: ID
}

type Subscription {
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  contentArea(where: ContentAreaSubscriptionWhereInput): ContentAreaSubscriptionPayload
  contentText(where: ContentTextSubscriptionWhereInput): ContentTextSubscriptionPayload
  country(where: CountrySubscriptionWhereInput): CountrySubscriptionPayload
  customer(where: CustomerSubscriptionWhereInput): CustomerSubscriptionPayload
  grind(where: GrindSubscriptionWhereInput): GrindSubscriptionPayload
  grindOption(where: GrindOptionSubscriptionWhereInput): GrindOptionSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  orderLine(where: OrderLineSubscriptionWhereInput): OrderLineSubscriptionPayload
  origin(where: OriginSubscriptionWhereInput): OriginSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  productImage(where: ProductImageSubscriptionWhereInput): ProductImageSubscriptionPayload
  region(where: RegionSubscriptionWhereInput): RegionSubscriptionPayload
  review(where: ReviewSubscriptionWhereInput): ReviewSubscriptionPayload
  sKU(where: SKUSubscriptionWhereInput): SKUSubscriptionPayload
  subCategory(where: SubCategorySubscriptionWhereInput): SubCategorySubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  vendor(where: VendorSubscriptionWhereInput): VendorSubscriptionPayload
}

type User {
  id: ID!
  email: String!
  phone: Int
  customer: Customer
  vendor: Vendor
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  phone: Int
  customer: CustomerCreateOneWithoutUserInput
  vendor: VendorCreateOneWithoutUserInput
}

input UserCreateOneWithoutCustomerInput {
  create: UserCreateWithoutCustomerInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutVendorInput {
  create: UserCreateWithoutVendorInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutCustomerInput {
  id: ID
  email: String!
  phone: Int
  vendor: VendorCreateOneWithoutUserInput
}

input UserCreateWithoutVendorInput {
  id: ID
  email: String!
  phone: Int
  customer: CustomerCreateOneWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  phone: Int
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  phone: Int
  customer: CustomerUpdateOneWithoutUserInput
  vendor: VendorUpdateOneWithoutUserInput
}

input UserUpdateManyMutationInput {
  email: String
  phone: Int
}

input UserUpdateOneRequiredWithoutCustomerInput {
  create: UserCreateWithoutCustomerInput
  update: UserUpdateWithoutCustomerDataInput
  upsert: UserUpsertWithoutCustomerInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutVendorInput {
  create: UserCreateWithoutVendorInput
  update: UserUpdateWithoutVendorDataInput
  upsert: UserUpsertWithoutVendorInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutCustomerDataInput {
  email: String
  phone: Int
  vendor: VendorUpdateOneWithoutUserInput
}

input UserUpdateWithoutVendorDataInput {
  email: String
  phone: Int
  customer: CustomerUpdateOneWithoutUserInput
}

input UserUpsertWithoutCustomerInput {
  update: UserUpdateWithoutCustomerDataInput!
  create: UserCreateWithoutCustomerInput!
}

input UserUpsertWithoutVendorInput {
  update: UserUpdateWithoutVendorDataInput!
  create: UserCreateWithoutVendorInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: Int
  phone_not: Int
  phone_in: [Int!]
  phone_not_in: [Int!]
  phone_lt: Int
  phone_lte: Int
  phone_gt: Int
  phone_gte: Int
  customer: CustomerWhereInput
  vendor: VendorWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
  phone: Int
}

type Vendor {
  id: ID!
  stripeId: String
  organizationNumber: Int!
  displayName: String!
  address: String!
  bankAccount: String
  logoImage: String
  facebookPageURL: String
  contactPerson: String
  user: User!
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
}

type VendorConnection {
  pageInfo: PageInfo!
  edges: [VendorEdge]!
  aggregate: AggregateVendor!
}

input VendorCreateInput {
  id: ID
  stripeId: String
  organizationNumber: Int!
  displayName: String!
  address: String!
  bankAccount: String
  logoImage: String
  facebookPageURL: String
  contactPerson: String
  user: UserCreateOneWithoutVendorInput!
  products: ProductCreateManyWithoutVendorInput
}

input VendorCreateOneInput {
  create: VendorCreateInput
  connect: VendorWhereUniqueInput
}

input VendorCreateOneWithoutProductsInput {
  create: VendorCreateWithoutProductsInput
  connect: VendorWhereUniqueInput
}

input VendorCreateOneWithoutUserInput {
  create: VendorCreateWithoutUserInput
  connect: VendorWhereUniqueInput
}

input VendorCreateWithoutProductsInput {
  id: ID
  stripeId: String
  organizationNumber: Int!
  displayName: String!
  address: String!
  bankAccount: String
  logoImage: String
  facebookPageURL: String
  contactPerson: String
  user: UserCreateOneWithoutVendorInput!
}

input VendorCreateWithoutUserInput {
  id: ID
  stripeId: String
  organizationNumber: Int!
  displayName: String!
  address: String!
  bankAccount: String
  logoImage: String
  facebookPageURL: String
  contactPerson: String
  products: ProductCreateManyWithoutVendorInput
}

type VendorEdge {
  node: Vendor!
  cursor: String!
}

enum VendorOrderByInput {
  id_ASC
  id_DESC
  stripeId_ASC
  stripeId_DESC
  organizationNumber_ASC
  organizationNumber_DESC
  displayName_ASC
  displayName_DESC
  address_ASC
  address_DESC
  bankAccount_ASC
  bankAccount_DESC
  logoImage_ASC
  logoImage_DESC
  facebookPageURL_ASC
  facebookPageURL_DESC
  contactPerson_ASC
  contactPerson_DESC
}

type VendorPreviousValues {
  id: ID!
  stripeId: String
  organizationNumber: Int!
  displayName: String!
  address: String!
  bankAccount: String
  logoImage: String
  facebookPageURL: String
  contactPerson: String
}

type VendorSubscriptionPayload {
  mutation: MutationType!
  node: Vendor
  updatedFields: [String!]
  previousValues: VendorPreviousValues
}

input VendorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VendorWhereInput
  AND: [VendorSubscriptionWhereInput!]
  OR: [VendorSubscriptionWhereInput!]
  NOT: [VendorSubscriptionWhereInput!]
}

input VendorUpdateDataInput {
  stripeId: String
  organizationNumber: Int
  displayName: String
  address: String
  bankAccount: String
  logoImage: String
  facebookPageURL: String
  contactPerson: String
  user: UserUpdateOneRequiredWithoutVendorInput
  products: ProductUpdateManyWithoutVendorInput
}

input VendorUpdateInput {
  stripeId: String
  organizationNumber: Int
  displayName: String
  address: String
  bankAccount: String
  logoImage: String
  facebookPageURL: String
  contactPerson: String
  user: UserUpdateOneRequiredWithoutVendorInput
  products: ProductUpdateManyWithoutVendorInput
}

input VendorUpdateManyMutationInput {
  stripeId: String
  organizationNumber: Int
  displayName: String
  address: String
  bankAccount: String
  logoImage: String
  facebookPageURL: String
  contactPerson: String
}

input VendorUpdateOneRequiredInput {
  create: VendorCreateInput
  update: VendorUpdateDataInput
  upsert: VendorUpsertNestedInput
  connect: VendorWhereUniqueInput
}

input VendorUpdateOneWithoutProductsInput {
  create: VendorCreateWithoutProductsInput
  update: VendorUpdateWithoutProductsDataInput
  upsert: VendorUpsertWithoutProductsInput
  delete: Boolean
  disconnect: Boolean
  connect: VendorWhereUniqueInput
}

input VendorUpdateOneWithoutUserInput {
  create: VendorCreateWithoutUserInput
  update: VendorUpdateWithoutUserDataInput
  upsert: VendorUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: VendorWhereUniqueInput
}

input VendorUpdateWithoutProductsDataInput {
  stripeId: String
  organizationNumber: Int
  displayName: String
  address: String
  bankAccount: String
  logoImage: String
  facebookPageURL: String
  contactPerson: String
  user: UserUpdateOneRequiredWithoutVendorInput
}

input VendorUpdateWithoutUserDataInput {
  stripeId: String
  organizationNumber: Int
  displayName: String
  address: String
  bankAccount: String
  logoImage: String
  facebookPageURL: String
  contactPerson: String
  products: ProductUpdateManyWithoutVendorInput
}

input VendorUpsertNestedInput {
  update: VendorUpdateDataInput!
  create: VendorCreateInput!
}

input VendorUpsertWithoutProductsInput {
  update: VendorUpdateWithoutProductsDataInput!
  create: VendorCreateWithoutProductsInput!
}

input VendorUpsertWithoutUserInput {
  update: VendorUpdateWithoutUserDataInput!
  create: VendorCreateWithoutUserInput!
}

input VendorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  stripeId: String
  stripeId_not: String
  stripeId_in: [String!]
  stripeId_not_in: [String!]
  stripeId_lt: String
  stripeId_lte: String
  stripeId_gt: String
  stripeId_gte: String
  stripeId_contains: String
  stripeId_not_contains: String
  stripeId_starts_with: String
  stripeId_not_starts_with: String
  stripeId_ends_with: String
  stripeId_not_ends_with: String
  organizationNumber: Int
  organizationNumber_not: Int
  organizationNumber_in: [Int!]
  organizationNumber_not_in: [Int!]
  organizationNumber_lt: Int
  organizationNumber_lte: Int
  organizationNumber_gt: Int
  organizationNumber_gte: Int
  displayName: String
  displayName_not: String
  displayName_in: [String!]
  displayName_not_in: [String!]
  displayName_lt: String
  displayName_lte: String
  displayName_gt: String
  displayName_gte: String
  displayName_contains: String
  displayName_not_contains: String
  displayName_starts_with: String
  displayName_not_starts_with: String
  displayName_ends_with: String
  displayName_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  bankAccount: String
  bankAccount_not: String
  bankAccount_in: [String!]
  bankAccount_not_in: [String!]
  bankAccount_lt: String
  bankAccount_lte: String
  bankAccount_gt: String
  bankAccount_gte: String
  bankAccount_contains: String
  bankAccount_not_contains: String
  bankAccount_starts_with: String
  bankAccount_not_starts_with: String
  bankAccount_ends_with: String
  bankAccount_not_ends_with: String
  logoImage: String
  logoImage_not: String
  logoImage_in: [String!]
  logoImage_not_in: [String!]
  logoImage_lt: String
  logoImage_lte: String
  logoImage_gt: String
  logoImage_gte: String
  logoImage_contains: String
  logoImage_not_contains: String
  logoImage_starts_with: String
  logoImage_not_starts_with: String
  logoImage_ends_with: String
  logoImage_not_ends_with: String
  facebookPageURL: String
  facebookPageURL_not: String
  facebookPageURL_in: [String!]
  facebookPageURL_not_in: [String!]
  facebookPageURL_lt: String
  facebookPageURL_lte: String
  facebookPageURL_gt: String
  facebookPageURL_gte: String
  facebookPageURL_contains: String
  facebookPageURL_not_contains: String
  facebookPageURL_starts_with: String
  facebookPageURL_not_starts_with: String
  facebookPageURL_ends_with: String
  facebookPageURL_not_ends_with: String
  contactPerson: String
  contactPerson_not: String
  contactPerson_in: [String!]
  contactPerson_not_in: [String!]
  contactPerson_lt: String
  contactPerson_lte: String
  contactPerson_gt: String
  contactPerson_gte: String
  contactPerson_contains: String
  contactPerson_not_contains: String
  contactPerson_starts_with: String
  contactPerson_not_starts_with: String
  contactPerson_ends_with: String
  contactPerson_not_ends_with: String
  user: UserWhereInput
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  AND: [VendorWhereInput!]
  OR: [VendorWhereInput!]
  NOT: [VendorWhereInput!]
}

input VendorWhereUniqueInput {
  id: ID
  bankAccount: String
}
`
      }
