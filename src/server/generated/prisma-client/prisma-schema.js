module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCountry {
  count: Int!
}

type AggregateCustomer {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateProductImage {
  count: Int!
}

type AggregateRegion {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateVendor {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Country {
  id: ID!
  name: String!
  region: Region
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
}

type CountryConnection {
  pageInfo: PageInfo!
  edges: [CountryEdge]!
  aggregate: AggregateCountry!
}

input CountryCreateInput {
  id: ID
  name: String!
  region: RegionCreateOneWithoutCountriesInput
  products: ProductCreateManyWithoutCountryInput
}

input CountryCreateManyWithoutRegionInput {
  create: [CountryCreateWithoutRegionInput!]
  connect: [CountryWhereUniqueInput!]
}

input CountryCreateOneWithoutProductsInput {
  create: CountryCreateWithoutProductsInput
  connect: CountryWhereUniqueInput
}

input CountryCreateWithoutProductsInput {
  id: ID
  name: String!
  region: RegionCreateOneWithoutCountriesInput
}

input CountryCreateWithoutRegionInput {
  id: ID
  name: String!
  products: ProductCreateManyWithoutCountryInput
}

type CountryEdge {
  node: Country!
  cursor: String!
}

enum CountryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type CountryPreviousValues {
  id: ID!
  name: String!
}

input CountryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [CountryScalarWhereInput!]
  OR: [CountryScalarWhereInput!]
  NOT: [CountryScalarWhereInput!]
}

type CountrySubscriptionPayload {
  mutation: MutationType!
  node: Country
  updatedFields: [String!]
  previousValues: CountryPreviousValues
}

input CountrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CountryWhereInput
  AND: [CountrySubscriptionWhereInput!]
  OR: [CountrySubscriptionWhereInput!]
  NOT: [CountrySubscriptionWhereInput!]
}

input CountryUpdateInput {
  name: String
  region: RegionUpdateOneWithoutCountriesInput
  products: ProductUpdateManyWithoutCountryInput
}

input CountryUpdateManyDataInput {
  name: String
}

input CountryUpdateManyMutationInput {
  name: String
}

input CountryUpdateManyWithoutRegionInput {
  create: [CountryCreateWithoutRegionInput!]
  delete: [CountryWhereUniqueInput!]
  connect: [CountryWhereUniqueInput!]
  set: [CountryWhereUniqueInput!]
  disconnect: [CountryWhereUniqueInput!]
  update: [CountryUpdateWithWhereUniqueWithoutRegionInput!]
  upsert: [CountryUpsertWithWhereUniqueWithoutRegionInput!]
  deleteMany: [CountryScalarWhereInput!]
  updateMany: [CountryUpdateManyWithWhereNestedInput!]
}

input CountryUpdateManyWithWhereNestedInput {
  where: CountryScalarWhereInput!
  data: CountryUpdateManyDataInput!
}

input CountryUpdateOneWithoutProductsInput {
  create: CountryCreateWithoutProductsInput
  update: CountryUpdateWithoutProductsDataInput
  upsert: CountryUpsertWithoutProductsInput
  delete: Boolean
  disconnect: Boolean
  connect: CountryWhereUniqueInput
}

input CountryUpdateWithoutProductsDataInput {
  name: String
  region: RegionUpdateOneWithoutCountriesInput
}

input CountryUpdateWithoutRegionDataInput {
  name: String
  products: ProductUpdateManyWithoutCountryInput
}

input CountryUpdateWithWhereUniqueWithoutRegionInput {
  where: CountryWhereUniqueInput!
  data: CountryUpdateWithoutRegionDataInput!
}

input CountryUpsertWithoutProductsInput {
  update: CountryUpdateWithoutProductsDataInput!
  create: CountryCreateWithoutProductsInput!
}

input CountryUpsertWithWhereUniqueWithoutRegionInput {
  where: CountryWhereUniqueInput!
  update: CountryUpdateWithoutRegionDataInput!
  create: CountryCreateWithoutRegionInput!
}

input CountryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  region: RegionWhereInput
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  AND: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  NOT: [CountryWhereInput!]
}

input CountryWhereUniqueInput {
  id: ID
  name: String
}

type Customer {
  id: ID!
  firstName: String!
  lastName: String!
  address: String!
  user: User!
}

type CustomerConnection {
  pageInfo: PageInfo!
  edges: [CustomerEdge]!
  aggregate: AggregateCustomer!
}

input CustomerCreateInput {
  id: ID
  firstName: String!
  lastName: String!
  address: String!
  user: UserCreateOneWithoutCustomerInput!
}

input CustomerCreateOneWithoutUserInput {
  create: CustomerCreateWithoutUserInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateWithoutUserInput {
  id: ID
  firstName: String!
  lastName: String!
  address: String!
}

type CustomerEdge {
  node: Customer!
  cursor: String!
}

enum CustomerOrderByInput {
  id_ASC
  id_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  address_ASC
  address_DESC
}

type CustomerPreviousValues {
  id: ID!
  firstName: String!
  lastName: String!
  address: String!
}

type CustomerSubscriptionPayload {
  mutation: MutationType!
  node: Customer
  updatedFields: [String!]
  previousValues: CustomerPreviousValues
}

input CustomerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerWhereInput
  AND: [CustomerSubscriptionWhereInput!]
  OR: [CustomerSubscriptionWhereInput!]
  NOT: [CustomerSubscriptionWhereInput!]
}

input CustomerUpdateInput {
  firstName: String
  lastName: String
  address: String
  user: UserUpdateOneRequiredWithoutCustomerInput
}

input CustomerUpdateManyMutationInput {
  firstName: String
  lastName: String
  address: String
}

input CustomerUpdateOneWithoutUserInput {
  create: CustomerCreateWithoutUserInput
  update: CustomerUpdateWithoutUserDataInput
  upsert: CustomerUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: CustomerWhereUniqueInput
}

input CustomerUpdateWithoutUserDataInput {
  firstName: String
  lastName: String
  address: String
}

input CustomerUpsertWithoutUserInput {
  update: CustomerUpdateWithoutUserDataInput!
  create: CustomerCreateWithoutUserInput!
}

input CustomerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  user: UserWhereInput
  AND: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
}

input CustomerWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createCountry(data: CountryCreateInput!): Country!
  updateCountry(data: CountryUpdateInput!, where: CountryWhereUniqueInput!): Country
  updateManyCountries(data: CountryUpdateManyMutationInput!, where: CountryWhereInput): BatchPayload!
  upsertCountry(where: CountryWhereUniqueInput!, create: CountryCreateInput!, update: CountryUpdateInput!): Country!
  deleteCountry(where: CountryWhereUniqueInput!): Country
  deleteManyCountries(where: CountryWhereInput): BatchPayload!
  createCustomer(data: CustomerCreateInput!): Customer!
  updateCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateManyCustomers(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): BatchPayload!
  upsertCustomer(where: CustomerWhereUniqueInput!, create: CustomerCreateInput!, update: CustomerUpdateInput!): Customer!
  deleteCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteManyCustomers(where: CustomerWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createProductImage(data: ProductImageCreateInput!): ProductImage!
  updateProductImage(data: ProductImageUpdateInput!, where: ProductImageWhereUniqueInput!): ProductImage
  updateManyProductImages(data: ProductImageUpdateManyMutationInput!, where: ProductImageWhereInput): BatchPayload!
  upsertProductImage(where: ProductImageWhereUniqueInput!, create: ProductImageCreateInput!, update: ProductImageUpdateInput!): ProductImage!
  deleteProductImage(where: ProductImageWhereUniqueInput!): ProductImage
  deleteManyProductImages(where: ProductImageWhereInput): BatchPayload!
  createRegion(data: RegionCreateInput!): Region!
  updateRegion(data: RegionUpdateInput!, where: RegionWhereUniqueInput!): Region
  updateManyRegions(data: RegionUpdateManyMutationInput!, where: RegionWhereInput): BatchPayload!
  upsertRegion(where: RegionWhereUniqueInput!, create: RegionCreateInput!, update: RegionUpdateInput!): Region!
  deleteRegion(where: RegionWhereUniqueInput!): Region
  deleteManyRegions(where: RegionWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createVendor(data: VendorCreateInput!): Vendor!
  updateVendor(data: VendorUpdateInput!, where: VendorWhereUniqueInput!): Vendor
  updateManyVendors(data: VendorUpdateManyMutationInput!, where: VendorWhereInput): BatchPayload!
  upsertVendor(where: VendorWhereUniqueInput!, create: VendorCreateInput!, update: VendorUpdateInput!): Vendor!
  deleteVendor(where: VendorWhereUniqueInput!): Vendor
  deleteManyVendors(where: VendorWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Product {
  id: ID!
  title: String!
  flavorProfile: String
  description: String!
  info: String
  published: Boolean!
  vendor: Vendor
  country: Country
  productImages(where: ProductImageWhereInput, orderBy: ProductImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductImage!]
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: ID
  title: String!
  flavorProfile: String
  description: String!
  info: String
  published: Boolean!
  vendor: VendorCreateOneWithoutProductsInput
  country: CountryCreateOneWithoutProductsInput
  productImages: ProductImageCreateManyWithoutProductInput
}

input ProductCreateManyWithoutCountryInput {
  create: [ProductCreateWithoutCountryInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateManyWithoutVendorInput {
  create: [ProductCreateWithoutVendorInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateOneWithoutProductImagesInput {
  create: ProductCreateWithoutProductImagesInput
  connect: ProductWhereUniqueInput
}

input ProductCreateWithoutCountryInput {
  id: ID
  title: String!
  flavorProfile: String
  description: String!
  info: String
  published: Boolean!
  vendor: VendorCreateOneWithoutProductsInput
  productImages: ProductImageCreateManyWithoutProductInput
}

input ProductCreateWithoutProductImagesInput {
  id: ID
  title: String!
  flavorProfile: String
  description: String!
  info: String
  published: Boolean!
  vendor: VendorCreateOneWithoutProductsInput
  country: CountryCreateOneWithoutProductsInput
}

input ProductCreateWithoutVendorInput {
  id: ID
  title: String!
  flavorProfile: String
  description: String!
  info: String
  published: Boolean!
  country: CountryCreateOneWithoutProductsInput
  productImages: ProductImageCreateManyWithoutProductInput
}

type ProductEdge {
  node: Product!
  cursor: String!
}

type ProductImage {
  id: ID!
  image: String!
  product: Product
}

type ProductImageConnection {
  pageInfo: PageInfo!
  edges: [ProductImageEdge]!
  aggregate: AggregateProductImage!
}

input ProductImageCreateInput {
  id: ID
  image: String!
  product: ProductCreateOneWithoutProductImagesInput
}

input ProductImageCreateManyWithoutProductInput {
  create: [ProductImageCreateWithoutProductInput!]
  connect: [ProductImageWhereUniqueInput!]
}

input ProductImageCreateWithoutProductInput {
  id: ID
  image: String!
}

type ProductImageEdge {
  node: ProductImage!
  cursor: String!
}

enum ProductImageOrderByInput {
  id_ASC
  id_DESC
  image_ASC
  image_DESC
}

type ProductImagePreviousValues {
  id: ID!
  image: String!
}

input ProductImageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  AND: [ProductImageScalarWhereInput!]
  OR: [ProductImageScalarWhereInput!]
  NOT: [ProductImageScalarWhereInput!]
}

type ProductImageSubscriptionPayload {
  mutation: MutationType!
  node: ProductImage
  updatedFields: [String!]
  previousValues: ProductImagePreviousValues
}

input ProductImageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductImageWhereInput
  AND: [ProductImageSubscriptionWhereInput!]
  OR: [ProductImageSubscriptionWhereInput!]
  NOT: [ProductImageSubscriptionWhereInput!]
}

input ProductImageUpdateInput {
  image: String
  product: ProductUpdateOneWithoutProductImagesInput
}

input ProductImageUpdateManyDataInput {
  image: String
}

input ProductImageUpdateManyMutationInput {
  image: String
}

input ProductImageUpdateManyWithoutProductInput {
  create: [ProductImageCreateWithoutProductInput!]
  delete: [ProductImageWhereUniqueInput!]
  connect: [ProductImageWhereUniqueInput!]
  set: [ProductImageWhereUniqueInput!]
  disconnect: [ProductImageWhereUniqueInput!]
  update: [ProductImageUpdateWithWhereUniqueWithoutProductInput!]
  upsert: [ProductImageUpsertWithWhereUniqueWithoutProductInput!]
  deleteMany: [ProductImageScalarWhereInput!]
  updateMany: [ProductImageUpdateManyWithWhereNestedInput!]
}

input ProductImageUpdateManyWithWhereNestedInput {
  where: ProductImageScalarWhereInput!
  data: ProductImageUpdateManyDataInput!
}

input ProductImageUpdateWithoutProductDataInput {
  image: String
}

input ProductImageUpdateWithWhereUniqueWithoutProductInput {
  where: ProductImageWhereUniqueInput!
  data: ProductImageUpdateWithoutProductDataInput!
}

input ProductImageUpsertWithWhereUniqueWithoutProductInput {
  where: ProductImageWhereUniqueInput!
  update: ProductImageUpdateWithoutProductDataInput!
  create: ProductImageCreateWithoutProductInput!
}

input ProductImageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  product: ProductWhereInput
  AND: [ProductImageWhereInput!]
  OR: [ProductImageWhereInput!]
  NOT: [ProductImageWhereInput!]
}

input ProductImageWhereUniqueInput {
  id: ID
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  flavorProfile_ASC
  flavorProfile_DESC
  description_ASC
  description_DESC
  info_ASC
  info_DESC
  published_ASC
  published_DESC
}

type ProductPreviousValues {
  id: ID!
  title: String!
  flavorProfile: String
  description: String!
  info: String
  published: Boolean!
}

input ProductScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  flavorProfile: String
  flavorProfile_not: String
  flavorProfile_in: [String!]
  flavorProfile_not_in: [String!]
  flavorProfile_lt: String
  flavorProfile_lte: String
  flavorProfile_gt: String
  flavorProfile_gte: String
  flavorProfile_contains: String
  flavorProfile_not_contains: String
  flavorProfile_starts_with: String
  flavorProfile_not_starts_with: String
  flavorProfile_ends_with: String
  flavorProfile_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  info: String
  info_not: String
  info_in: [String!]
  info_not_in: [String!]
  info_lt: String
  info_lte: String
  info_gt: String
  info_gte: String
  info_contains: String
  info_not_contains: String
  info_starts_with: String
  info_not_starts_with: String
  info_ends_with: String
  info_not_ends_with: String
  published: Boolean
  published_not: Boolean
  AND: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  NOT: [ProductScalarWhereInput!]
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateInput {
  title: String
  flavorProfile: String
  description: String
  info: String
  published: Boolean
  vendor: VendorUpdateOneWithoutProductsInput
  country: CountryUpdateOneWithoutProductsInput
  productImages: ProductImageUpdateManyWithoutProductInput
}

input ProductUpdateManyDataInput {
  title: String
  flavorProfile: String
  description: String
  info: String
  published: Boolean
}

input ProductUpdateManyMutationInput {
  title: String
  flavorProfile: String
  description: String
  info: String
  published: Boolean
}

input ProductUpdateManyWithoutCountryInput {
  create: [ProductCreateWithoutCountryInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutCountryInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutCountryInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithoutVendorInput {
  create: [ProductCreateWithoutVendorInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutVendorInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutVendorInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput!
  data: ProductUpdateManyDataInput!
}

input ProductUpdateOneWithoutProductImagesInput {
  create: ProductCreateWithoutProductImagesInput
  update: ProductUpdateWithoutProductImagesDataInput
  upsert: ProductUpsertWithoutProductImagesInput
  delete: Boolean
  disconnect: Boolean
  connect: ProductWhereUniqueInput
}

input ProductUpdateWithoutCountryDataInput {
  title: String
  flavorProfile: String
  description: String
  info: String
  published: Boolean
  vendor: VendorUpdateOneWithoutProductsInput
  productImages: ProductImageUpdateManyWithoutProductInput
}

input ProductUpdateWithoutProductImagesDataInput {
  title: String
  flavorProfile: String
  description: String
  info: String
  published: Boolean
  vendor: VendorUpdateOneWithoutProductsInput
  country: CountryUpdateOneWithoutProductsInput
}

input ProductUpdateWithoutVendorDataInput {
  title: String
  flavorProfile: String
  description: String
  info: String
  published: Boolean
  country: CountryUpdateOneWithoutProductsInput
  productImages: ProductImageUpdateManyWithoutProductInput
}

input ProductUpdateWithWhereUniqueWithoutCountryInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutCountryDataInput!
}

input ProductUpdateWithWhereUniqueWithoutVendorInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutVendorDataInput!
}

input ProductUpsertWithoutProductImagesInput {
  update: ProductUpdateWithoutProductImagesDataInput!
  create: ProductCreateWithoutProductImagesInput!
}

input ProductUpsertWithWhereUniqueWithoutCountryInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutCountryDataInput!
  create: ProductCreateWithoutCountryInput!
}

input ProductUpsertWithWhereUniqueWithoutVendorInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutVendorDataInput!
  create: ProductCreateWithoutVendorInput!
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  flavorProfile: String
  flavorProfile_not: String
  flavorProfile_in: [String!]
  flavorProfile_not_in: [String!]
  flavorProfile_lt: String
  flavorProfile_lte: String
  flavorProfile_gt: String
  flavorProfile_gte: String
  flavorProfile_contains: String
  flavorProfile_not_contains: String
  flavorProfile_starts_with: String
  flavorProfile_not_starts_with: String
  flavorProfile_ends_with: String
  flavorProfile_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  info: String
  info_not: String
  info_in: [String!]
  info_not_in: [String!]
  info_lt: String
  info_lte: String
  info_gt: String
  info_gte: String
  info_contains: String
  info_not_contains: String
  info_starts_with: String
  info_not_starts_with: String
  info_ends_with: String
  info_not_ends_with: String
  published: Boolean
  published_not: Boolean
  vendor: VendorWhereInput
  country: CountryWhereInput
  productImages_every: ProductImageWhereInput
  productImages_some: ProductImageWhereInput
  productImages_none: ProductImageWhereInput
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
}

type Query {
  country(where: CountryWhereUniqueInput!): Country
  countries(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Country]!
  countriesConnection(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CountryConnection!
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer]!
  customersConnection(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  productImage(where: ProductImageWhereUniqueInput!): ProductImage
  productImages(where: ProductImageWhereInput, orderBy: ProductImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductImage]!
  productImagesConnection(where: ProductImageWhereInput, orderBy: ProductImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductImageConnection!
  region(where: RegionWhereUniqueInput!): Region
  regions(where: RegionWhereInput, orderBy: RegionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Region]!
  regionsConnection(where: RegionWhereInput, orderBy: RegionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RegionConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  vendor(where: VendorWhereUniqueInput!): Vendor
  vendors(where: VendorWhereInput, orderBy: VendorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vendor]!
  vendorsConnection(where: VendorWhereInput, orderBy: VendorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VendorConnection!
  node(id: ID!): Node
}

type Region {
  id: ID!
  name: String!
  countries(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Country!]
}

type RegionConnection {
  pageInfo: PageInfo!
  edges: [RegionEdge]!
  aggregate: AggregateRegion!
}

input RegionCreateInput {
  id: ID
  name: String!
  countries: CountryCreateManyWithoutRegionInput
}

input RegionCreateOneWithoutCountriesInput {
  create: RegionCreateWithoutCountriesInput
  connect: RegionWhereUniqueInput
}

input RegionCreateWithoutCountriesInput {
  id: ID
  name: String!
}

type RegionEdge {
  node: Region!
  cursor: String!
}

enum RegionOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type RegionPreviousValues {
  id: ID!
  name: String!
}

type RegionSubscriptionPayload {
  mutation: MutationType!
  node: Region
  updatedFields: [String!]
  previousValues: RegionPreviousValues
}

input RegionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RegionWhereInput
  AND: [RegionSubscriptionWhereInput!]
  OR: [RegionSubscriptionWhereInput!]
  NOT: [RegionSubscriptionWhereInput!]
}

input RegionUpdateInput {
  name: String
  countries: CountryUpdateManyWithoutRegionInput
}

input RegionUpdateManyMutationInput {
  name: String
}

input RegionUpdateOneWithoutCountriesInput {
  create: RegionCreateWithoutCountriesInput
  update: RegionUpdateWithoutCountriesDataInput
  upsert: RegionUpsertWithoutCountriesInput
  delete: Boolean
  disconnect: Boolean
  connect: RegionWhereUniqueInput
}

input RegionUpdateWithoutCountriesDataInput {
  name: String
}

input RegionUpsertWithoutCountriesInput {
  update: RegionUpdateWithoutCountriesDataInput!
  create: RegionCreateWithoutCountriesInput!
}

input RegionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  countries_every: CountryWhereInput
  countries_some: CountryWhereInput
  countries_none: CountryWhereInput
  AND: [RegionWhereInput!]
  OR: [RegionWhereInput!]
  NOT: [RegionWhereInput!]
}

input RegionWhereUniqueInput {
  id: ID
  name: String
}

type Subscription {
  country(where: CountrySubscriptionWhereInput): CountrySubscriptionPayload
  customer(where: CustomerSubscriptionWhereInput): CustomerSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  productImage(where: ProductImageSubscriptionWhereInput): ProductImageSubscriptionPayload
  region(where: RegionSubscriptionWhereInput): RegionSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  vendor(where: VendorSubscriptionWhereInput): VendorSubscriptionPayload
}

type User {
  id: ID!
  email: String!
  phone: Int
  customer: Customer
  vendor: Vendor
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  phone: Int
  customer: CustomerCreateOneWithoutUserInput
  vendor: VendorCreateOneWithoutUserInput
}

input UserCreateOneWithoutCustomerInput {
  create: UserCreateWithoutCustomerInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutVendorInput {
  create: UserCreateWithoutVendorInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutCustomerInput {
  id: ID
  email: String!
  phone: Int
  vendor: VendorCreateOneWithoutUserInput
}

input UserCreateWithoutVendorInput {
  id: ID
  email: String!
  phone: Int
  customer: CustomerCreateOneWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  phone: Int
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  phone: Int
  customer: CustomerUpdateOneWithoutUserInput
  vendor: VendorUpdateOneWithoutUserInput
}

input UserUpdateManyMutationInput {
  email: String
  phone: Int
}

input UserUpdateOneRequiredWithoutCustomerInput {
  create: UserCreateWithoutCustomerInput
  update: UserUpdateWithoutCustomerDataInput
  upsert: UserUpsertWithoutCustomerInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutVendorInput {
  create: UserCreateWithoutVendorInput
  update: UserUpdateWithoutVendorDataInput
  upsert: UserUpsertWithoutVendorInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutCustomerDataInput {
  email: String
  phone: Int
  vendor: VendorUpdateOneWithoutUserInput
}

input UserUpdateWithoutVendorDataInput {
  email: String
  phone: Int
  customer: CustomerUpdateOneWithoutUserInput
}

input UserUpsertWithoutCustomerInput {
  update: UserUpdateWithoutCustomerDataInput!
  create: UserCreateWithoutCustomerInput!
}

input UserUpsertWithoutVendorInput {
  update: UserUpdateWithoutVendorDataInput!
  create: UserCreateWithoutVendorInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: Int
  phone_not: Int
  phone_in: [Int!]
  phone_not_in: [Int!]
  phone_lt: Int
  phone_lte: Int
  phone_gt: Int
  phone_gte: Int
  customer: CustomerWhereInput
  vendor: VendorWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
  phone: Int
}

type Vendor {
  id: ID!
  displayName: String!
  organizationNumber: Int!
  bankAccount: String!
  logoImage: String!
  facebookPageURL: String
  address: String!
  user: User!
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
}

type VendorConnection {
  pageInfo: PageInfo!
  edges: [VendorEdge]!
  aggregate: AggregateVendor!
}

input VendorCreateInput {
  id: ID
  displayName: String!
  organizationNumber: Int!
  bankAccount: String!
  logoImage: String!
  facebookPageURL: String
  address: String!
  user: UserCreateOneWithoutVendorInput!
  products: ProductCreateManyWithoutVendorInput
}

input VendorCreateOneWithoutProductsInput {
  create: VendorCreateWithoutProductsInput
  connect: VendorWhereUniqueInput
}

input VendorCreateOneWithoutUserInput {
  create: VendorCreateWithoutUserInput
  connect: VendorWhereUniqueInput
}

input VendorCreateWithoutProductsInput {
  id: ID
  displayName: String!
  organizationNumber: Int!
  bankAccount: String!
  logoImage: String!
  facebookPageURL: String
  address: String!
  user: UserCreateOneWithoutVendorInput!
}

input VendorCreateWithoutUserInput {
  id: ID
  displayName: String!
  organizationNumber: Int!
  bankAccount: String!
  logoImage: String!
  facebookPageURL: String
  address: String!
  products: ProductCreateManyWithoutVendorInput
}

type VendorEdge {
  node: Vendor!
  cursor: String!
}

enum VendorOrderByInput {
  id_ASC
  id_DESC
  displayName_ASC
  displayName_DESC
  organizationNumber_ASC
  organizationNumber_DESC
  bankAccount_ASC
  bankAccount_DESC
  logoImage_ASC
  logoImage_DESC
  facebookPageURL_ASC
  facebookPageURL_DESC
  address_ASC
  address_DESC
}

type VendorPreviousValues {
  id: ID!
  displayName: String!
  organizationNumber: Int!
  bankAccount: String!
  logoImage: String!
  facebookPageURL: String
  address: String!
}

type VendorSubscriptionPayload {
  mutation: MutationType!
  node: Vendor
  updatedFields: [String!]
  previousValues: VendorPreviousValues
}

input VendorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VendorWhereInput
  AND: [VendorSubscriptionWhereInput!]
  OR: [VendorSubscriptionWhereInput!]
  NOT: [VendorSubscriptionWhereInput!]
}

input VendorUpdateInput {
  displayName: String
  organizationNumber: Int
  bankAccount: String
  logoImage: String
  facebookPageURL: String
  address: String
  user: UserUpdateOneRequiredWithoutVendorInput
  products: ProductUpdateManyWithoutVendorInput
}

input VendorUpdateManyMutationInput {
  displayName: String
  organizationNumber: Int
  bankAccount: String
  logoImage: String
  facebookPageURL: String
  address: String
}

input VendorUpdateOneWithoutProductsInput {
  create: VendorCreateWithoutProductsInput
  update: VendorUpdateWithoutProductsDataInput
  upsert: VendorUpsertWithoutProductsInput
  delete: Boolean
  disconnect: Boolean
  connect: VendorWhereUniqueInput
}

input VendorUpdateOneWithoutUserInput {
  create: VendorCreateWithoutUserInput
  update: VendorUpdateWithoutUserDataInput
  upsert: VendorUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: VendorWhereUniqueInput
}

input VendorUpdateWithoutProductsDataInput {
  displayName: String
  organizationNumber: Int
  bankAccount: String
  logoImage: String
  facebookPageURL: String
  address: String
  user: UserUpdateOneRequiredWithoutVendorInput
}

input VendorUpdateWithoutUserDataInput {
  displayName: String
  organizationNumber: Int
  bankAccount: String
  logoImage: String
  facebookPageURL: String
  address: String
  products: ProductUpdateManyWithoutVendorInput
}

input VendorUpsertWithoutProductsInput {
  update: VendorUpdateWithoutProductsDataInput!
  create: VendorCreateWithoutProductsInput!
}

input VendorUpsertWithoutUserInput {
  update: VendorUpdateWithoutUserDataInput!
  create: VendorCreateWithoutUserInput!
}

input VendorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  displayName: String
  displayName_not: String
  displayName_in: [String!]
  displayName_not_in: [String!]
  displayName_lt: String
  displayName_lte: String
  displayName_gt: String
  displayName_gte: String
  displayName_contains: String
  displayName_not_contains: String
  displayName_starts_with: String
  displayName_not_starts_with: String
  displayName_ends_with: String
  displayName_not_ends_with: String
  organizationNumber: Int
  organizationNumber_not: Int
  organizationNumber_in: [Int!]
  organizationNumber_not_in: [Int!]
  organizationNumber_lt: Int
  organizationNumber_lte: Int
  organizationNumber_gt: Int
  organizationNumber_gte: Int
  bankAccount: String
  bankAccount_not: String
  bankAccount_in: [String!]
  bankAccount_not_in: [String!]
  bankAccount_lt: String
  bankAccount_lte: String
  bankAccount_gt: String
  bankAccount_gte: String
  bankAccount_contains: String
  bankAccount_not_contains: String
  bankAccount_starts_with: String
  bankAccount_not_starts_with: String
  bankAccount_ends_with: String
  bankAccount_not_ends_with: String
  logoImage: String
  logoImage_not: String
  logoImage_in: [String!]
  logoImage_not_in: [String!]
  logoImage_lt: String
  logoImage_lte: String
  logoImage_gt: String
  logoImage_gte: String
  logoImage_contains: String
  logoImage_not_contains: String
  logoImage_starts_with: String
  logoImage_not_starts_with: String
  logoImage_ends_with: String
  logoImage_not_ends_with: String
  facebookPageURL: String
  facebookPageURL_not: String
  facebookPageURL_in: [String!]
  facebookPageURL_not_in: [String!]
  facebookPageURL_lt: String
  facebookPageURL_lte: String
  facebookPageURL_gt: String
  facebookPageURL_gte: String
  facebookPageURL_contains: String
  facebookPageURL_not_contains: String
  facebookPageURL_starts_with: String
  facebookPageURL_not_starts_with: String
  facebookPageURL_ends_with: String
  facebookPageURL_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  user: UserWhereInput
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  AND: [VendorWhereInput!]
  OR: [VendorWhereInput!]
  NOT: [VendorWhereInput!]
}

input VendorWhereUniqueInput {
  id: ID
  organizationNumber: Int
  bankAccount: String
}
`
      }
    